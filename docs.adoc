:page-layout: default
:page-permalink: /documentation/
:page-liquid:

= User Guide
:showtitle:
:toc:

+++
<span data-page-nav="{{ '/documentation' | prepend: site.baseurl }}"></span>
+++

== Getting Started

The easiest way to get started with Smooks is to download and try out some https://github.com/smooks/smooks-examples/tree/v2.0.0[examples]. The examples are the perfect base upon which to integrate Smooks into your application.

== Introduction

Smooks is an extensible Java framework for building XML and non-XML data (CSV, EDI, Java, etc...) fragment-based applications.

While Smooks can be used as a lightweight framework on which to hook your own processing logic for a wide range of data formats, out-of-the-box it ships with useful features that can be used individually or seamlessly together:

* *Java Binding*: Populate a POJO from a data stream (CSV, EDI, XML,
Java, etc...). Populated POJOs can either be the final result of a
transformation, or serve as a bridge for further transformations like
what is seen in template resources which generate textual results such
as XML. Additionally, supports Virtual Object Models (maps and lists of
typed data) that can be references from expression languages and
templating functionality.
* *Transformation*: Perform a wide range of data transformations - XML
to XML, CSV to XML, EDI to XML, XML to EDI, XML to CSV, Java to XML,
Java to EDI, Java to CSV, Java to Java, XML to Java, EDI to Java, etc...
* *Huge Message Processing*: Process huge messages (TBs) - split,
transform and route message fragments to JMS, file, database, and other
destinations.
* *Message Enrichment*: Enrich a message with data from a database, or
other data sources.
* *Complex Message Validation*: Rules-based fragment validation.
* *ORM Based Message Persistence*: Use an entity persistence framework
(like MyBatis, Hibernate, or any JPA compatible framework) to access a
database and use its query language or CRUD methods to read from it or
write to it. Use custom Data Access Objects (DAOs) to access a database
and use its CRUD methods to read from it or write to it.
* *Combine*: Leverage Smooks's transformation, routing and persistence
functionality to perform Extract Transform Load (ETL) operations.

=== Why Smooks?

Smooks started its life as a transformation solution. The main goal was
to perform "fragment-based transformations" on messages. Supporting
fragment-based transformation opened up the possibility of mixing and
matching different technologies within the context of a single
transformation. This meant that one could leverage different
technologies for transforming message fragments, depending on the type
of transformation required by the fragment in question.

In the process of building this fragment-based transformation solution,
we realised that we were actually building a much more general
fragment-based processing solution. We were building a solution that
supported targeting of custom link:#visitors[visitor] logic, of any
kind, at fragments of a message. The visitor logic did not need to be
restricted to the realm of message transformation. A visitor could be
implemented to perform all sorts of operations on message fragments (and
therefore a message as a whole). Up to the point of writing, Smooks has
support for the following forms of fragment-based message processing:

* Templating: XSLT or FreeMarker fragment transformations, with the
ability to be extended to other technologies.
* Java Binding: Bind fragments to POJOs.
* Splitting: Perform complex splitting of messages fragments, routing
the split message fragments over a range of different
transports/destinations such as filesystem, JMS, database, or ESB.
* Enrichment: Enrich message fragments with data from a database.
* Persistence: Persist message fragment data to a database using raw
SQL, or by reusing your existing JPA, Hibernate or MyBatis resources.
* Validation: Perform basic or complex validation on message fragment
data. This is more than simple type/value-range validation. Complex
rules based validation is also possible.

Smooks supports a wide range of data formats - XML, EDI, JSON, CSV, Java
(Java to Java!). A pluggable reader interface allows you to plug in a
reader implementation for any data format.

=== Fragment-Based Processing

The primary design goals of Smooks are to provide a framework within
which fragment-based processing can be performed on hierarchical data
(XML and non-XML) using existing data processing technologies (such as
XSLT, plain vanilla Java, Groovy script), providing a degree of
isolation between the different technologies.

A link:#visitors[visitor] targets a message fragment via the "selector"
value on the visitor's resource configuration. The targeted message
fragment can take in as much or as little of the message as you like. A
message fragment is identified by the name of the element enclosing the
fragment. You can capture the whole message using the element name of
the root fragment as the selector or through the special "#document"
selector.

You may wonder why we use and mix the terms "Fragment" and "Element".
Well the difference is a little subtle and often quite irrelevant, so it
is often OK to interchange the terms. Anyway, an "Element" is the outer
node (only) of a "Fragment". A "Fragment" is an "Element" and all its
child elements and content nodes (text, etc...). So when a piece of
visitor logic targets at a message fragment, that typically means that
that piece of logic can not only process (transform, etc...) the outer
"Element" of that fragment, but can also perform processing on child
nodes i.e. the fragment as a whole.

=== What's new in Smooks 2?

Smooks 2 introduces the DFDL cartridge and revamps its EDI cartridge,
while dropping support for Java 7 along with a few other notable
breaking changes:

* DFDL cartridge
** DFDL is a specification for describing file formats in XML. The DFDL
cartridge leverages https://daffodil.apache.org/[Apache Daffodil] to
parse files and unparse XML. This opens up Smooks to an incredible
number of file formats like SWIFT, ISO8583, HL7, and many more.
* Pipeline support
** Compose any series of transformations on an event outside the main
execution context before directing the pipeline output to the execution
result stream or to other destinations
* Complete overhaul of the EDI cartridge
** Rewritten to extend the DFDL cartridge and provide much better
support for reading EDI documents.
** New functionality for serialising EDI documents.
** As in previous Smooks versions, incorporated special support for
EDIFACT.
* SAX NG filter
** Supersedes the SAX and DOM filters
** Brings with it a new visitor API which unifies the SAX and DOM
visitor APIs
** Cartridges migrated to SAX NG
** Supports XSLT and StringTemplate resources unlike the legacy SAX
filter
* Visitor mementos
** A convenient way to stash and un-stash a visitor's state during its
execution lifecycle
* Independent release cycles for all cartridges and one
link:/maven#bill-of-materials--bom-[Maven BOM] (bill of materials) to
track them all
* License change
** After reaching consensus among our code contributors, we've
dual-licensed Smooks under
https://choosealicense.com/licenses/lgpl-3.0/[LGPL v3.0] and
https://choosealicense.com/licenses/apache-2.0/[Apache License 2.0].
This license change keeps Smooks open source while adopting a permissive
stance to modifications.
* New Smooks XSD schema
(_xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"_)
** Uniform XML namespace declarations
*** Dropped _default-selector-namespace_ and _selector-namespace_ XML
attributes in favour of declaring namespaces within the standard _xmlns_
attribute from the _smooks-resource-config_ element.
** Removed _default-selector_ attribute from _smooks-resource-config_
element: selectors need to be set explicitly.
* Dropped Smooks-specific annotations in favour of JSR annotations
** Farewell @ConfigParam, @Config, @AppContext, and @StreamResultWriter.
Welcome @Inject.
** Farewell @Initialize and @Uninitialize. Welcome @PostConstruct and
@PreDestroy.
* Separate top-level Java namespaces for API and implementation
** API interfaces and internal classes were relocated to
_org.smooks.api_ and _org.smooks.engine_, respectively
* Numerous dependency updates
* Maven coordinates change
** We are now publishing Smooks artifacts under Maven group IDs prefixed
with "org.smooks".
* Replaced default SAX parser implementation from Apache Xerces to
https://github.com/FasterXML/woodstox[FasterXML's Woodstox]

=== Migrating from Smooks 1.7 to 2.0

. Smooks 2 no longer supports Java 7. Your application needs to be
compiled to at least Java 8 to run Smooks 2.
. Replace references to Java packages `org.milyn` with `org.smooks.api`,
`org.smooks.engine`, `org.smooks.io` or `org.smooks.support`.
. Change legacy document root fragment selectors from `$document` to
`#document`.
. Replace Smooks Maven coordinates to match the coordinates as described
in the link:/maven#artifact-ids[Maven guide].
. Replace `ExecutionContext#isDefaultSerializationOn` method calls with
`ExecutionContext#getDeliveryConfig#isDefaultSerializationOn`.
. Replace `ExecutionContext#getContext` method calls with
`ExecutionContext#getApplicationContext`.
. Replace `org.smooks.delivery.dom.serialize.SerializationVisitor`
references with `org.smooks.api.resource.visitor.SerializerVisitor`.
. Replace `org.smooks.cdr.annotation.AppContext` annotations with
`javax.inject.Inject` annotations.
. Replace `org.smooks.cdr.annotation.ConfigParam` annotations with
`javax.inject.Inject` annotations:
* Substitute the `@ConfigParam` name attribute with the
`@javax.inject.Named` annotation.
* Wrap `java.util.Optional` around the field to mimic the behaviour of
the `@ConfigParam` optional attribute.
. Replace `org.smooks.delivery.annotation.Initialize` annotations with
`javax.annotation.PostConstruct` annotations.
. Replace `org.smooks.delivery.annotation.Uninitialize` annotations with
`javax.annotation.PreDestroy` annotations.
. Replace references to `org.smooks.javabean.DataDecode` with
`org.smooks.api.converter.TypeConverterFactory`.
. Replace references to `org.smooks.cdr.annotation.Configurator` with
`org.smooks.api.lifecycle.LifecycleManager`.
. Replace references to `org.smooks.javabean.DataDecoderException` with
`org.smooks.api.converter.TypeConverterException`.
. Replace references to
`org.smooks.cdr.SmooksResourceConfigurationStore` with
`org.smooks.api.Registry`.
. Replace references to `org.milyn.cdr.SmooksResourceConfiguration` with
`org.smooks.api.resource.config.ResourceConfig`.

=== FAQs

See the link:/faq[FAQ].

=== Maven

For details on how to integrate Smooks into your project via Maven, see
the link:/maven[Maven guide].

== Basics

The most commonly accepted definition of Smooks would be that it is a
"Transformation Engine". However, at its core, Smooks makes no reference
to "data transformation". The core codebase is designed to hook custom
"visitor" logic into an event stream produced from a data source of some
kind. As such, in its simplest form, Smooks is a *Structured Data Event
Stream Processor*.

Of course, the most common application of this will be in the creation
of transformation solutions, that is, implementing a
link:#visitors[visitor] that reads the event stream produced from a data
source to produce a result of some other kind. However, Smooks's core
capabilities enable more than this. We have implemented a range of other
solutions based on this processing model:

* *Java Binding*: Population of a Java Object Model from the Source
message.
* *Message Splitting & Routing*: The ability to perform complex
splitting and routing operations on the Source message, including
routing to multiple destinations concurrently, as well as routing
different data formats concurrently (XML, EDI, CSV, Java, etc...).
* *Huge Message Processing*: The ability to declaratively consume
(transform, or split and route) huge message without writing lots of
high maintenance code.

=== Basic Processing Model

As stated above, the basic principle of Smooks is to take a data
*source* of some kind (e.g., XML) and from it generate an *event
stream*, to which you apply *visitors* to produce a *result* of some
other kind (e.g., EDI).

Several data source and result types are supported which translate to
different transformation types, including (but not limited to):

* XML to XML
* XML to Java
* Java to XML
* Java to Java
* EDI to XML
* EDI to Java
* Java to EDI
* CSV to XML
* CSV to ...
* etc...

Smooks 2 maps the source to the result with the help of a highly-tunable
SAX event model. The hierarchical events generated from an XML source
(startElement, endElement, etc...) drives the SAX event model. However,
the event model can be just as easily applied to other
structured/hierarchical data sources (EDI, CSV, Java, etc...). The most
important events are typically the *visitBefore* and *visitAfter*
events. The following illustration tries to convey the hierarchical
nature of these events.

image:../assets/images/Event-model.gif[Image:event-model.gif]

=== Simple Example

In order to consume the SAX event stream produced from the source
message, you need to implement one or more of the
link:javadoc/v2.0.0/smooks/org/smooks/delivery/sax/ng/SaxNgVisitor.html[SaxNgVisitor]
interfaces (depending on which events you need to consume).

The following is a very simple example of how you implement a visitor
and target it at the *visitBefore* and *visitAfter* events for a
specific element in the event stream. In this case we target the visitor
logic at the element events.

image:../assets/images/Simple-example.png[Image:simple-example.png]

As you can see, the visitor implementation is very simple; one method
implementation per event. To target this implementation at the __
element *visitBefore* and *visitAfter* events, we need to create a Smook
configuration as shown (more on "Resource Configurations" in the
following sections).

The Smooks code executing this is a two liner:

[source,java]
----
Smooks smooks = new Smooks("/smooks/echo-example.xml");  
smooks.filterSource(new StreamSource(inputStream));
----

Observe that in this case the program doesn't produce a result. It
doesn't even interact with the filtering process in any way because it
doesn't provide an
link:/javadoc/v2.0.0/smooks/org/smooks/container/ExecutionContext.html[ExecutionContext]
to the
link:/javadoc/v2.0.0/smooks/org/smooks/Smooks.html[Smooks].filterSource
method call.

This example illustrated the lower level mechanics of the Smooks's
programming model. In reality, however, users are not going to want to
solve their problems by writing boilerplate Java code. For this reason,
Smooks ships with substantial pre-built functionality, that is, ready to
use visitors. We bundle visitors based on functionality and call these
bundles *Cartridges*.

=== Smooks Resources (Visitors, etc...)

A Smooks execution consumes a data stream of one form or another (XML,
EDI, Java, JSON, CSV, etc...), and from it, generates an event stream
that fires different visitors (Java, Groovy, DFDL, XSLT, etc...). The
result of this process can be to produce a new data stream in a
different format (i.e., a traditional "transformation"), bind data from
the source message data stream to Java objects to go on and produce a
populated Java object graph (Java binding), produce many smaller
messages (message splitting), etc...

At its core, Smooks views visitors and other abstractions as
"resources", to be applied based on a given event *selector* (i.e.,
event from the source data event stream). This is a general processing
model and makes sense from the point of view of Smooks and its
architecture. However, its generality can be daunting from a usability
perspective because everything looks very similar in the configuration.
To help with this, Smooks 1.1 introduced an "Extensible Configuration
Model" feature. This allows specific resource types (JavaBean binding
configs, FreeMarker template configs, etc...) to be specified in the
configuration using dedicated XSD namespaces of their own.

Example (Java Binding Resource):

[source,xml]
----
<jb:bean beanId="lineOrder" class="example.trgmodel.LineOrder" createOnElement="example.srcmodel.Order">  
    <jb:wiring property="lineItems" beanIdRef="lineItems" />  
    <jb:value property="customerId" data="header/customerNumber" />  
    <jb:value property="customerName" data="header/customerName" />  
</jb:bean>
----

Example (FreeMarker Template Resource):

[source,xml]
----
<ftl:freemarker applyOnElement="order-item">
    <ftl:template><!-- <item>
    <id>${.vars["order-item"].@id}</id>
    <productId>${.vars["order-item"].product}</productId>
    <quantity>${.vars["order-item"].quantity}</quantity>
    <price>${.vars["order-item"].price}</price>
</item>
    -->
    </ftl:template>
</ftl:freemarker>
----

You can see that when comparing the above examples to earlier versions
of Smooks:

. The user now has a more strongly typed domain specific configuration
in each case and so easier to read.
. Because the v1.1+ configurations are XSD based, the user also gets
auto-completion support from their IDE.
. No longer any need to define the actual handler for the given resource
type e.g., the BeanPopulator for Java bindings.

==== Visitors

Central to how Smooks works is the concept of a visitor. A visitor is a
Java class performing a specific task on the targeted message fragment
such as applying an XSLT, binding fragment data to a Java object,
performing message fragment validation, etc...

==== Selectors

Resource selectors are a very important part of Smooks and how it works.
They instruct Smooks to apply configured visitors on message fragments,
as well working as a simple opaque lookup value for non-visitor logic.

When the resource is a visitor (e.g. <jb:bean>, <ftl:freemarker>,
etc...), Smooks will interpret the selector as an
http://www.w3.org/TR/xpath/[XPath] (like) expression. There are a number
of things to be aware of:

. The order in which the http://www.w3.org/TR/xpath/[XPath] expression
is applied is the reverse of normal order e.g. as applied by an XSLT.
Smooks works backwards from the targeted fragment element, as opposed to
forwards from the message root element.
. Not all of the http://www.w3.org/TR/xpath/[XPath] specification is
supported. A selector supports the following XPath syntax:
* 'text()' and attribute (e.g. '@x') value selectors, with both Literal
and Numeric e.g. "a/b[text() = 'abc']", "a/b[text() = 123]", "a/b[@id =
'abc']", "a/b[@id = 123]".
** Note: 'text()' is only supported on the last selector step in an
expression e.g. "a/b[text() = 'abc']" is legal while "a/b[text() =
'abc']/c" is illegal.
** Note: 'text()' is only supported on SAXVisitor implementations that
implement the SAXVisitAfter interface *only*. If the SAXVisitor
implements the SAXVisitBefore or SAXVisitChildren interfaces, an error
will result.
* "And" and "Or" logical operations e.g. "a/b[text() = 'abc' and @id =
123]", "a/b[text() = 'abc' or @id = 123]"
* Namespaces on both the elements and attributes e.g.
"a:order/b:address[@b:city = 'NY']".
** Note: This requires the namespace prefix-to-URI mappings to be
defined. If not defined, a configuration error will result. See the
link:#namespace-declaration[Namespace Declaration] section for more
details.
* Supports "=" (equals), "!=" (not equals), "<" (less than), ">"
(greater than).
* Index selectors e.g. "a/b[3]"

==== Namespace Declaration

You bind a selector prefix to a namespace by declaring the namespace
using the _xmlns_ attribute:

[source,xml]
----
<?xml version="1.0"?>  
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"  
                      xmlns:c="http://c" xmlns:d="http://d">     

    <resource-config selector="c:item[@c:code = '8655']/d:units[text() = 1]">  
        <resource>com.acme.visitors.MyCustomVisitorImpl</resource>  
    </resource-config>  

</smooks-resource-list>
----

Alternatively, you can declare namespace prefix-to-URI mappings with the
legacy core configuration namespace element:

[source,xml]
----
<?xml version="1.0"?>  
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"  
                      xmlns:core="https://www.smooks.org/xsd/smooks/smooks-core-1.6.xsd">  

    <core:namespaces>  
        <core:namespace prefix="c" uri="http://c"/>  
        <core:namespace prefix="d" uri="http://d"/>  
    </core:namespaces>  

    <resource-config selector="c:item[@c:code = '8655']/d:units[text() = 1]">  
        <resource>com.acme.visitors.MyCustomVisitorImpl</resource>  
    </resource-config>  

</smooks-resource-list>
----

=== Cartridge

The basic functionality of Smooks can be extended through the creation
of a "Smooks Cartridge". A cartridge is a Java archive (JAR) containing
reusable content handlers (i.e., resources). A Smooks Cartridge should
provide "ready to use" support for a specific type of XML processing.

For a complete list of the cartridges supported by Smooks, see the
https://github.com/smooks/smooks/tree/v1.7.1/smooks-cartridges[Cartridges
page].

=== Filter

A Smooks filter is responsible for delivering generated events from a
reader to Smooks resources. Smooks 1 had the DOM and SAX filters. The
DOM filter was simple to use but kept all the events in memory while the
SAX filter, though more complex, delivered the events in streaming
fashion. Having two filter types meant two different visitor APIs and
execution paths, with all the baggage it entailed.

Smooks 2 unifies the legacy DOM and SAX filters without sacrificing
convenience or performance. The new SAX NG filter drops the API
distinction between DOM and SAX. Instead, the filter streams SAX events
as *partial* DOM elements to SAX NG visitors targeting the element. A
SAX NG visitor can read the targeted element as well as any of the
element's ancestors but not the targeted element's children or siblings
in order to keep the memory footprint to a minimum.

The SAX NG filter can mimic DOM by setting its _max.node.depth_
parameter to 0 (default value is 1), allowing each visitor to process
the complete DOM tree in its _visitAfter(...)_ method:

[source,xml]
----
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd">

    <params>
        <param name="max.node.depth">0</param>
    </params>
    ...
</smooks>
----

A _max.node.depth_ value of greater than 1 will tell the filter to read
and keep an element's descendants up to the desired depth. Take the
following input as an example:

[source,xml]
----
<order id="332">  
    <header>  
        <customer number="123">Joe</customer>  
    </header>  
    <order-items>  
        <order-item id="1">  
            <product>1</product>  
            <quantity>2</quantity>  
            <price>8.80</price>  
        </order-item>  
        <order-item id="2">  
            <product>2</product>  
            <quantity>2</quantity>  
            <price>8.80</price>  
        </order-item>  
        <order-item id="3">  
            <product>3</product>  
            <quantity>2</quantity>  
            <price>8.80</price>  
        </order-item>  
    </order-items>  
</order>
----

Along with the config:

[source,xml]
----
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd">

    <params>
        <param name="max.node.depth">2</param>
    </params>

    <resource-config selector="order-item">
        <resource>org.acme.MyVisitor</resource>
    </resource-config>

</smooks>
----

At any given time, there will always be a single _order-item_ in memory
containing _product_ because the _max.node.depth_ is 2. Each new
_order-item_ overwrites the previous _order-item_ to minimise the memory
footprint. The _visitAfter(...)_ method of _MyVisitor_ is invoked 3
times, each invocation corresponding to an _order-item_ fragment. The
first invocation will process:

[source,xml]
----
<order-item id='1'>  
    <product>2</product>
</order-item>
----

While the second invocation will process:

[source,xml]
----
<order-item id='2'>  
    <product>2</product>
</order-item>
----

Whereas the last invocation will process:

[source,xml]
----
<order-item id='3'>  
    <product>3</product>
</order-item>
----

Programmatically, implementing
_org.smooks.api.resource.visitor.sax.ng.ParameterizedVisitor_ will give
you fine-grained control over the visitor's targeted element depth:

[source,java]
----
...
public class DomVisitor implements ParameterizedVisitor {

    @Override
    public void visitBefore(Element element, ExecutionContext executionContext) {
    }

    @Override
    public void visitAfter(Element element, ExecutionContext executionContext) {
        System.out.println("Element: " + XmlUtil.serialize(element, true));
    }

    @Override
    public int getMaxNodeDepth() {
        return Integer.MAX_VALUE;
    }
}
----

_getMaxNodeDepth()_ returns an integer denoting the targeted element's
maximum tree depth the visitor can accept in its _visitAfter_ method.

=== The Bean Context

The *bean context* (also known as "bean map") is a container for Objects
which can be accessed within the Smooks filter process. One bean context
is created per execution context (i.e. per Smooks.filterSource
operation). Every bean, created by the cartridge, is put into this
context under its *beanId*. If you want the contents of the bean context
to be returned at the end of the Smooks.filterSource process, supply a
*org.smooks.io.payload.JavaResult* object in the call to
Smooks.filterSource method. The following example illustrates this
principal:

[source,java]
----
//Get the data to filter  
StreamSource source = new StreamSource(getClass().getResourceAsStream("data.xml"));  

//Create a Smooks instance (cachable)  
Smooks smooks = new Smooks("smooks-config.xml");  

//Create the JavaResult, which will contain the filter result after filtering  
JavaResult result = new JavaResult();  

//Filter the data from the source, putting the result into the JavaResult  
smooks.filterSource(source, result);  

//Getting the Order bean which was created by the JavaBean cartridge  
Order order = (Order)result.getBean("order");
----

If you need to access the bean context beans at runtime (e.g., from a
customer visitor implementation), you do so via the *BeanContext*
object. The "BeanContext" object can be retrieved from the
*ExecutionContext* via the *getBeanContext()* method. When adding or
retrieving objects from the BeanContext you should first retrieve a
*BeanId* object from the *BeanIdStore*. The BeanId object is a special
key that ensures higher performance then String keys, however String
keys are also supported. The BeanIdStore must be retrieved from the
*ApplicationContext* via the *getBeanIdStore()* method. A BeanId object
can be created by calling the *register("beanId name")* method. If you
know that the BeanId is already registered then you can retrieve it by
calling the *getBeanId("beanId name")* method. BeanId objects are
ApplicationContext scoped objects. You normally register them in the
initialization method of your custom visitor implemention and then put
them as properties in the visitor object. You can then use them in the
'visitBefore' and 'visitAfter' methods. The BeanId objects and the
BeanIdStore are thread safe.

==== Pre Installed Beans

A number of pre-installed beans are available in the Bean Context at
runtime:

* *PUUID*: UniqueId bean. This bean provides unique identifiers for the
filtering ExecutionContext.
link:/javadoc/v1.7.1/smooks/org/milyn/javabean/context/preinstalled/UniqueID.html[See
Javadoc].
* *PTIME*: Time bean. This bean provides time based data for the
filtering ExecutionContext.
link:/javadoc/v1.7.1/smooks/org/milyn/javabean/context/preinstalled/Time.html[See
Javadoc].

The following are examples of how each of these would be used in a
FreeMarker template.

Unique ID of the ExecutionContext (message being filtered):

....
${PUUID.execContext}
....

Random Unique ID:

....
${PUUID.random}
....

Message Filtering start time (in milliseconds):

....
${PTIME.startMillis}
....

Message Filtering start time (in nanoseconds):

....
${PTIME.startNanos}
....

Message Filtering start time (Date):

....
${PTIME.startDate}
....

Time now (in milliseconds):

....
${PTIME.nowMillis}
....

Time now (in nanoSeconds):

....
${PTIME.nowNanos}
....

Time now (Date):

....
${PTIME.nowDate}
....

link:/javadoc/v1.7.1/smooks/org/milyn/javabean/context/preinstalled/package-summary.html[See
Javadoc]

=== Multiple Outputs/Results

This section looks at the different ways in which Smooks can produce
"Output" from the Filtering process.

Smooks can "present" output to the outside world in the following ways:

. *"In-Result" Instances*: Returned in the
http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/Result.html[Result]
instances passed to the
link:/javadoc/v1.7.1/smooks/org/milyn/Smooks.html#filterSource(javax.xml.transform.Source,%20javax.xml.transform.Result...)[Smooks.filterSource]
method.
. *During the Filtering Process*: Output generated and sent to external
endpoints (ESB Services, Files, JMS Destinations, DBs, etc...) during
the Filtering process. This is where message fragment events are used to
trigger routing of message fragments to external endpoints e.g. when
link:#splitting--routing[Splitting and Routing] fragments of a message.

A very important point to remember is that Smooks can generate
output/results in either or both of the above ways, all in a single
filtering pass of a message stream. It doesn't need to filter a message
stream multiple times in order to generate multiple outputs/results.
This is critical in terms of performance/efficiency.

==== "In-Result" Instances

A look at the Smooks API reveals that Smooks can be supplied with
multiple
http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/Result.html[Result]
instances:

public void filterSource(Source source, Result... results) throws
SmooksException

In terms of the types of
http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/Result.html[Result]
that Smooks can work with, we're talking about the standard JDK
http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/stream/StreamResult.html[StreamResult]
and
http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/dom/DOMResult.html[DOMResult]
types, as well as some Smooks "specializations":

. link:/javadoc/v1.7.1/smooks/org/milyn/payload/JavaResult.html[JavaResult]:
Result type for capturing the contents of the Smooks Java Bean context.
. link:/javadoc/v1.7.1/smooks/org/milyn/validation/ValidationResult.html[ValidationResult]:
Result type for capturing link:#validating-data[Validation] Results.
. link:/javadoc/v1.7.1/smooks/org/milyn/payload/StringResult.html[StringResult]:
Simple Result type used mainly when writing tests. Simple
http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/stream/StreamResult.html[StreamResult]
extension wrapping a
http://java.sun.com/j2se/1.5.0/docs/api/java/io//StringWriter.html[StringWriter].

This is obviously the most common method of capturing output from the
Smooks filtering process.

*NOTE*:

_As yet, Smooks does not support capturing of
http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/Result.html[Result]
data to multiple
http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/Result.html[Result]
instances of the same type. For example, you can specify multiple
http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/stream/StreamResult.html[StreamResult]
instances in the
link:/javadoc/v1.7.1/smooks/org/milyn/Smooks.html#filterSource(javax.xml.transform.Source,%20javax.xml.transform.Result...)[Smooks.filterSource]
method call, but Smooks will only output to one of these
http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/stream/StreamResult.html[StreamResult]
instances (the first one)._

===== StreamResults / DOMResults

These
http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/Result.html[Result]
types receive "special" attention from Smooks. As Smooks process a
message
http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/Source.html[Source],
it produces a stream of events. If a
http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/stream/StreamResult.html[StreamResult]
or
http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/dom/DOMResult.html[DOMResult]
is supplied in the
link:/javadoc/v1.7.1/smooks/org/milyn/Smooks.html#filterSource(javax.xml.transform.Source,%20javax.xml.transform.Result...)[Smooks.filterSource]
call, Smooks will (by default - see
link:#filter-settings[default.serialization.on] global parameter)
serialize the event stream (produced from the
http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/Source.html[Source])
to the supplied
http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/stream/StreamResult.html[StreamResult]
or
http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/dom/DOMResult.html[DOMResult]
as XML. Obviously, a visitor can be configured/applied to the event
stream before serialization.

This is the mechanism used to perform a standard 1-input/1-xml-output
character based transformation.

==== During the Filtering Process

Smooks is also able to generate different types of output during the
link:/javadoc/v1.7.1/smooks/org/milyn/Smooks.html#filterSource(javax.xml.transform.Source,%20javax.xml.transform.Result...)[Smooks.filterSource]
process i.e. as it is filtering the message event stream and before it
reaches the end of the message. A classic example of this being when it
is used to link:#splitting--routing[split and route] message fragments
to different types of endpoints for processing by other processes.

So one might wonder why Smooks doesn't "batch up" the message data and
produce all the results/outputs after filtering the complete message.
Well the answer is straightforward enough:

. Performance!!
. It's just easier this way because you can utilize the message event
stream to trigger the fragment transform and routing operations.

Consider an Order message that has hundreds of thousands (or millions)
of Order Items that need to be split out and routed to different
departments in different formats, based on different criteria. The only
way of handing messages of this magnitude is by streaming the process.

=== Checking the Smooks Execution Process

As Smooks performs the filtering process (processing the Event Stream
generated from the Source), it publishes events that can be captured and
programmatically analyzed during/after execution.? The easiest way to
generate an execution report out of Smooks is to configure the
ExecutionContext to generate a report. Smooks supports generation of a
HTML report via the HtmlReportGenerator class.

The following is an example of how to configure Smooks to generate a
HTML report.

[source,java]
----
Smooks smooks = new Smooks("/smooks/smooks-transform-x.xml");  
ExecutionContext execContext = smooks.createExecutionContext();  

execContext.setEventListener(new HtmlReportGenerator("/tmp/smooks-report.html"));  
smooks.filterSource(execContext, new StreamSource(inputStream), new StreamResult(outputStream));
----

The HtmlReportGenerator is a very useful tool during development with
Smooks. It's the nearest thing Smooks currently has to an IDE based
Debugger (which we hope to have in a future release). It can be very
useful for diagnosing issues, or simply as a tool for comprehending a
Smooks transformation.

An example HtmlReportGenerator report can be seen
http://www.milyn.org/docs/smooks-report/report.html[online here].

Of course you can also write and use your own
link:/javadoc/v1.7.1/smooks/org/milyn/event/ExecutionEventListener.html[ExecutionEventListener]
implementations.

=== Terminating the Filtering Process

Sometimes you want/need to terminate the Smooks filtering process before
reaching the end of a message. This can be done by using a configuration
in the Smooks configuration. This configuration only works for the SAX
NG and SAX filters - it doesn't really make sense to add it for DOM.

The following is an example configuration that terminates filtering at
the end of the customer fragment of the message:

[source,xml]
----
<?xml version="1.0"?>  
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"   
                      xmlns:core="https://www.smooks.org/xsd/smooks/smooks-core-1.6.xsd">  

    <!-- Visitors... -->  
    <core:terminate onElement="customer"/>  

</smooks-resource-list>
----

The default behavior is to terminate at the end of the targeted fragment
(i.e. on the "visitAfter" event). To terminate at the start (on the
"visitBefore" event):

[source,xml]
----
<?xml version="1.0"?>  
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"   
                      xmlns:core="https://www.smooks.org/xsd/smooks/smooks-core-1.6.xsd">  

    <!-- Visitors... -->  
    <core:terminate onElement="customer" terminateBefore="true"/>  

</smooks-resource-list>
----

=== Global Configurations

Global configuration settings are, as the name implies, configuration
options that can be set once and be applied to all resources in a
configuration.

Smooks supports two types of globals, default properties and global
parameters:

* *Global Configuration Parameters*: Every in a Smooks configuration can
specify elements for configuration parameters. These parameter values
are available at runtime through the
link:/javadoc/v2.0.0/smooks/org/smooks/api/resource/config/ResourceConfig.html[ResourceConfig],
or are reflectively injected through the *@Inject* annotation. Global
Configuration Parameters are parameters that are defined centrally (see
below) and are accessible to all runtime components via the
link:/javadoc/v1.7.1/smooks/org/milyn/container/ExecutionContext.html[ExecutionContext]
(Vs the
link:/javadoc/v2.0.0/smooks/org/smooks/api/resource/config/ResourceConfig.html[ResourceConfig]).
More on this in the following sections.
* *Default Properties*: Specify default values for attributes. These
defaults are automatically applied to
link:/javadoc/v2.0.0/smooks/org/smooks/api/resource/config/ResourceConfig.html[ResourceConfig]s
when their corresponding does not specify the attribute. More on this in
the following section.

==== Global Configuration Parameters

Global properties differ from the default properties in that they are
not specified on the root element and are not automatically applied to
resources.

Global parameters are specified in a *<params>* element:

[source,xml]
----
<params>  
    <param name="xyz.param1">param1-val</param>  
</params>
----

Global Configuration Parameters are accessible via the
link:/javadoc/v1.7.1/smooks/org/milyn/container/ExecutionContext.html[ExecutionContext]
e.g.:

[source,java]
----
public void visitAfter(Element element, ExecutionContext executionContext) {
    String param1 = executionContext.getConfigParameter("xyz.param1", "defaultValueABC");
    ....
}
----

==== Default Properties

Default properties are properties that can be set on the root element of
a Smooks configuration and have them applied to all resource
configurations in smooks-conf.xml file. For example, if you have a
resource configuration file in which all the resource configurations
have the same selector value, you could specify a
_default-target-profile=order_ to save specifying the profile on every
resource configuration:

[source,xml]
----
<?xml version="1.0"?>  
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"
                      default-target-profile="order">  

    <resource-config>  
        <resource>com.acme.VisitorA</resource>  
        ...  
    </resource-config>  

    <resource-config>  
        <resource>com.acme.VisitorB</resource>  
        ...  
    </resource-config>  

<smooks-resource-list>
----

The following default configuration options are available:

* *default-target-profile*: Default target profile that will be applied
to all resources in the smooks configuration file, where a
target-profile is not defined.
* *default-condition-ref*: Refers to a global condition by the
conditions id. This condition is applied to resources that define an
empty "condition" element (i.e. ) that does not reference a globally
defined condition.

=== Filter Settings

Filtering specific configurations are made through the *smooks-core*
configuration namespace
(https://www.smooks.org/xsd/smooks/smooks-core-1.6.xsd) introduced in
Smooks v1.3.

An example configuration:

[source,xml]
----
<?xml version="1.0"?>  
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"   
                      xmlns:core="https://www.smooks.org/xsd/smooks/smooks-core-1.6.xsd">  

    <core:filterSettings type="SAX-NG" defaultSerialization="true" terminateOnException="true"   
                         readerPoolSize="3" closeSource="true" closeResult="true" rewriteEntities="true" />  

    <!-- Other visitor configs etc... -->  

</smooks-resource-list>
----

* *type* Determines the type of processing model that will be used.
Either SAX NG, SAX or DOM. Please refer to
link:#filtering-process-selection-sax-ng-sax-or-dom[Filtering Process
Selection] for more information about the processing models. Default is
SAX NG (http://jira.codehaus.org/browse/MILYN-589[default was DOM in
Smooks v1.4 and before]).
* *defaultSerialization*: Determines if default serialization should be
switched on (default "true"). Default serialization being turned on
simply tells Smooks to locate a
http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/stream/StreamResult.html[StreamResult]
(or DOMResult) in the Result objects provided to the
link:/javadoc/v1.7.1/smooks/org/milyn/Smooks.html#filterSource(javax.xml.transform.Source,%20javax.xml.transform.Result...)[Smooks.filterSource]
method and to, by default, serialize all events to that Result. This
behavior can be turned off using this global configuration parameter and
can be overridden on a per fragment basis by targeting a visitor at that
fragment that takes ownership of the result writer (in the case of SAX
filtering), or simply modifies the DOM (in the case of DOM filtering).
As an example of this, see the
link:/javadoc/v1.7.1/smooks-cartridges/templating/org/milyn/templating/freemarker/FreeMarkerTemplateProcessor.html[FreeMarkerTemplateProcessor].
* *terminateOnException*: Determines whether an exception should
terminate processing (default "true").
* *closeSource*: Close Source instance streams passed to the
link:/javadoc/v1.7.1/smooks/org/milyn/Smooks.html#filterSource(javax.xml.transform.Source,%20javax.xml.transform.Result...)[Smooks.filterSource]
method (default "true"). The exception here is System.in, which will
never be closed.
* *closeResult*: Close Result streams passed to the
link:/javadoc/v1.7.1/smooks/org/milyn/Smooks.html#filterSource(javax.xml.transform.Source,%20javax.xml.transform.Result...)[Smooks.filterSource]
method (default "true"). The exception here is System.out and
System.err, which will never be closed.
* *rewriteEntities*: Rewrite XML entities when reading and writing
(default serialization) XML.
* *readerPoolSize*: Reader Pool Size (default 0). Some Reader
implementations are very expensive to create (e.g. Xerces). Pooling
Reader instances (i.e. reusing) can result in a huge performance
improvement, especially when processing lots of "small" messages. The
default value for this setting is 0 (i.e. unpooled - a new Reader
instance is created for each message). Configure in line with your
applications threading model.

=== Configuration Modularization

Smooks configurations are easily modularized through use of the
_<import>_ element. This allows you to split Smooks configurations into
multiple reusable configuration files and then compose the top level
configurations using the _<import>_ element e.g.

[source,xml]
----
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd">  

    <import file="bindings/order-binding.xml" />  
    <import file="templates/order-template.xml" />  

</smooks-resource-list>
----

You can also inject replacement tokens into the imported configuration
by using _<param>_ sub-elements on the _<import>_. This allows you to
make tweaks to the imported configuration.

[source,xml]
----
<!-- Top level configuration... -->  
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd">  

    <import file="bindings/order-binding.xml">  
        <param name="orderRootElement">order</param>  
    </import>  

</smooks-resource-list>  
----

[source,xml]
----
<!-- Imported parameterized bindings/order-binding.xml configuration... -->  
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"
                      xmlns:jb="https://www.smooks.org/xsd/smooks/javabean-1.6.xsd">  

    <jb:bean beanId="order" class="org.acme.Order" createOnElement="@orderRootElement@">  
        .....  
    </jb:bean>  

</smooks-resource-list>
----

Note how the replacement token injection points are specified using
*@tokenname@*.

== Consuming Input Data

Smooks relies on a "Stream Reader" for generating a stream of SAX events
from the Source message data stream. A Stream Reader is a class that
implements the
http://java.sun.com/j2se/1.5.0/docs/api/org/xml/sax/XMLReader.html[XMLReader
interface] (or the
link:/javadoc/v1.7.1/smooks/org/milyn/xml/SmooksXMLReader.html[SmooksXMLReader
interface]).

By default, Smooks uses the default XMLReader
(http://java.sun.com/j2se/1.5.0/docs/api/org/xml/sax/helpers/XMLReaderFactory.html#createXMLReader%28%29[XMLReaderFactory.createXMLReader()]),
but can be easily configured to read non-XML data Sources by configuring
a specialized XMLReader:

[source,xml]
----
<?xml version="1.0"?>  
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd">  

    <reader class="com.acme.ZZZZReader" />  

    <!--   
        Other Smooks resources, e.g. <jb:bean> configs for   
        binding data from the ZZZZ data stream into Java Objects....  
    -->  

</smooks-resource-list>
----

The reader can also be configured with a set of handlers, features and
parameters. Here is a full example configuration.

[source,xml]
----
<reader class="com.acme.ZZZZReader">  
    <handlers>  
        <handler class="com.X" />  
        <handler class="com.Y" />  
    </handlers>  
    <features>  
        <setOn feature="http://a" />  
        <setOn feature="http://b" />  
        <setOff feature="http://c" />  
        <setOff feature="http://d" />  
    </features>  
    <params>  
        <param name="param1">val1</param>  
        <param name="param2">val2</param>  
    </params>  
</reader>
----

As you can read in the subchapter of this chapter there are a number of
non-XML Readers available with Smooks out-of-the-box.

=== XML

By default Smooks reads XML data. To set features on the default XML
reader, simply omit the class name from the configuration:

[source,xml]
----
<reader>  
    <features>  
        <setOn feature="http://a" />  
        <setOn feature="http://b" />  
        <setOff feature="http://c" />  
        <setOff feature="http://d" />  
    </features>  
</reader>
----

=== CSV Cartridge

include::https://raw.githubusercontent.com/smooks/smooks-csv-cartridge/master/README.adoc[tag=smooks-csv-cartridge,leveloffset=2]

=== Fixed Length Cartridge

include::https://raw.githubusercontent.com/smooks/smooks-fixed-length-cartridge/master/README.adoc[tag=smooks-fixed-length-cartridge,leveloffset=2]

=== DFDL Cartridge

include::https://raw.githubusercontent.com/smooks/smooks-dfdl-cartridge/master/README.adoc[tag=smooks-dfdl-cartridge,leveloffset=2]

=== EDI Cartridge
:imagesdir: https://raw.githubusercontent.com/smooks/smooks-edi-cartridge/master

include::https://raw.githubusercontent.com/smooks/smooks-edi-cartridge/master/README.adoc[tag=smooks-edi-cartridge,leveloffset=1]

:imagesdir:

=== EDIFACT Cartridge

include::https://raw.githubusercontent.com/smooks/smooks-edi-cartridge/master/README.adoc[tag=smooks-edifact-cartridge,leveloffset=1]

=== JSON Cartridge

include::https://raw.githubusercontent.com/smooks/smooks-json-cartridge/master/README.adoc[tag=smooks-json-cartridge,leveloffset=2]

=== YAML Cartridge

include::https://raw.githubusercontent.com/smooks/smooks-yaml-cartridge/master/README.adoc[tag=smooks-yaml-cartridge,leveloffset=2]

=== JavaBean Cartridge
:imagesdir: https://raw.githubusercontent.com/smooks/smooks-javabean-cartridge/master

include::https://raw.githubusercontent.com/smooks/smooks-javabean-cartridge/master/README.adoc[tag=smooks-javabean-cartridge,leveloffset=2]

:imagesdir:

=== String manipulation functions for readers

The CSV and Fixed Length readers support string manipulation functions
that are executed on the input data before that the data is converted
into SAX events. The following functions are available:

* *upper_case*: Returns the upper case version of the string.
* *lower_case*: Returns the lower case version of the string.
* *cap_first*: Returns the string with the very first word of the string
capitalized.
* *uncap_first*: Returns the string with the very first word of the
string un-capitalized. The opposite to *cap_first*.
* *capitalize*: Returns the string with all words capitalized.
* *trim*: Returns the string without leading and trailing white-spaces.
* *left_trim*: Returns the string without leading white-spaces.
* *right_trim*: Returns the string without trailing white-spaces.

Functions can be chained via the point separator. Example:
*trim.upper_case*

It depends on the reader how the functions are defined per field. Please
look at the individual chapters of the readers for that information.

== Validating Data

=== Rules

Rules in Smooks refer to a general concept and is not specific to any
cartridge. A RuleProvider can be configured and referenced from other
components. As of Smooks v1.2, the only Cartridge using Rules
functionality is the link:#validation[Validation Cartridge].

So, lets start by looking at what rules in Smooks are, and how they are
used.

==== Rule Configuration

Rules are centrally defined through "ruleBase" definitions. A single
Smooks config can reference many "ruleBase" definitions. A rulesBase
configuration as a *name*, a rule *src* and a rule *provider*. The
format of the rule source ("src") is entirely dependent on the provider
implementation. The only requirement is that the individual rules be
named (unique within the context of a single source) so as they can be
referenced by their name.

An example of a ruleBase configuration is as follows:

[source,xml]
----
<?xml version="1.0"?>  
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"  
                      xmlns:rules="https://www.smooks.org/xsd/smooks/rules-1.1.xsd">  

    <rules:ruleBases>  
        <rules:ruleBase name="regexAddressing" src="/org/smooks/validation/address.properties"
                        provider="org.smooks.rules.regex.RegexProvider" />  
        <rules:ruleBase name="order" src="/org/smooks/validation/order/rules/order-rules.csv"
                        provider="org.smooks.rules.mvel.MVELProvider"/>  
    </rules:ruleBases>  

</smooks-resource-list>
----

===== Rulebase Configuration Options

The following are the configuration options for the configuration
element.

* *name*: Is used to reference this rule from other components, like
from a validation configuration that we will look at shortly. Required.
* *src*: Is a file or anything meaningful to the RuleProvider. This
could be a file containing rules for example. Required.
* *provider*: Is the actual provider implementation that you want to
use. This is where the different technologies come into play. In the
above configuration we have one RuleProvider that uses regular
expression. As you might have guessed you can specify multiple ruleBase
element and have as many RuleProviders you need. Required.

==== RuleProvider Implementations

Rule Providers implement the *org.smooks.rules.RuleProvider* interface.

Smooks v1.2 supports 2 RuleProvider implementations out-of-the-box:

. link:#regexprovider[RegexProvider]
. link:#mvelprovider[MVELProvider]

You can easily create custom RuleProvider implementations. Future
versions of Smooks will probably include support for e.g. a Drools
RuleProvider.

===== RegexProvider

As it's name suggests, the RegexProvider is based on regular expression.
It allows you to define low level rules specific to the format of
specific fields of data in the message being filtered e.g. that a
particular field is a valid email address.

Configuration of a Regex ruleBase would look like this:

[source,xml]
----
<?xml version="1.0"?>  
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"
                      xmlns:rules="https://www.smooks.org/xsd/smooks/rules-1.1.xsd">  

    <rules:ruleBases>  
        <rules:ruleBase name="customer" src="/org/smooks/validation/order/rules/customer.properties"
                        provider="org.smooks.rules.regex.RegexProvider"/>  
    </rules:ruleBases>  

</smooks-resource-list>
----

Regex expressions are defined in standard .properties file format. An
example of a "customer.properties" Regex rule definition file (from the
above example) might be as follows:

....
# Customer data rules...  
customerId=[A-Z][0-9]{5}  
customerName=[A-Z][a-z]*, [A-Z][a-z]
....

====== Useful Regular Expressions

The following is a list of "useful" regular expressions that we hope to
grow over time as a resource for people use Regex Rules.

See the http://regexlib.com/[Regular Expression Library].

[source,properties]
----
# Email Address Validation
email=^((?>[a-zA-Z\d!#$%&'*+\-/=?^_`{|}~]+\x20*|"((?=[\x01-\x7f])[^"\\]|\\[\x01-\x7f])*"\x20*)*(?<angle><))?((?!\.)(?>\.?[a-zA-Z\d!#$%&'*+\-/=?^_`{|}~]+)+|"((?=[\x01-\x7f])[^"\\]|\\[\x01-\x7f])*")@(((?!-)[a-zA-Z\d\-]+(?<!-)\.)+[a-zA-Z]{2,}|\[(((?(?<!\[)\.)(25[0-5]|2[0-4]\d|[01]?\d?\d)){4}|[a-zA-Z\d\-]*[a-zA-Z\d]:((?=[\x01-\x7f])[^\\\[\]]|\\[\x01-\x7f])+)\])(?(angle)>)$

# Matches a negative or positive percentage between 0 and 100 (inclusive). Accepts up to 2 decimal places.
percentage.withdecimal=^-?[0-9]{0,2}(\.[0-9]{1,2})?$|^-?(100)(\.[0]{1,2})?$

# HTTP/HTTPS Url
url.http=^(http|https)\://[a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,3}(:[a-zA-Z0-9]*)?/?([a-zA-Z0-9\-\._\?\,\'/\\\+&amp;%\$#\=~])*$
----

===== MVELProvider

The http://mvel.documentnode.com/[MVEL] Provider allows rules to be
defined as MVEL expressions. These expressions are executed on the
contents of the Smooks Javabean bean context. That means they require
Data to be bound (from the message being filtered) into Java objects in
the Smooks bean context. This allows you to define more complex (higher
level) rules on message fragments, such as "is the product in the
targeted order item fragment within the age eligibility constraints of
the customer specified in the order header details".

*Note*: _Be sure to read the section on link:#java-binding[Java
Binding]_.

Configuration of an MVEL ruleBase would look like this:

[source,xml]
----
<?xml version="1.0"?>  
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"  
                      xmlns:rules="https://www.smooks.org/xsd/smooks/rules-1.1.xsd">  

    <rules:ruleBases>  
        <rules:ruleBase name="order" src="/org/smooks/validation/order/rules/order-rules.csv" provider="org.smooks.rules.mvel.MVELProvider"/>  
    </rules:ruleBases>  

</smooks-resource-list>
----

MVEL rules must be defined as Comma Separated Value (CSV) files. The
easiest way to edit these files is through a Spreadsheet Application
(e.g. OpenOffice or Excel). Each rule record contains 2 fields:

. A Rule Name
. An MVEL Expression

Comment/header rows can be added by prefixing the first field with a
hash ('#') character.

An example of an MVEL rule CSV file as seen in OpenOffice is as follows:

image:../assets/images/MVEL-csv-rulebase.png[Image:MVEL-csv-rulebase.png]

=== Rule Based Validation

The Smooks Validation Cartridge builds on the functionality provided by
the link:#rules[Rules] Cartridge, to provide Rules based fragment
validation.

The type of validation provided by the components of the Smooks
Validation Cartridge allows you to perform more detailed validation
(over the likes of XSD/Relax) on message fragments. As with everything
in Smooks, the Validation functionality is supported across all
supported data formats. This means you can perform strong validation on
not just XML data, but also on EDI, JSON, CSV, etc...

Validation configurations are defined by the
https://www.smooks.org/xsd/smooks/validation-1.1.xsd configuration
namespace.

==== Validation Configuration

Smooks supports a number of different Rule Provider types that can be
used by the Validation Cartridge. They provide different levels of
validation. These different forms of Validation are configured in
exactly the same way. The Smooks Validation Cartridge sees a Rule
Provider as an abstract resource that it can target at message fragments
in order to perform validation on the data in that message fragment.

A Validation rule configuration is very simple. You simply need to
specify:

* *executeOn*: The fragment on which the rule is to be executed.
* *excecuteOnNS*: The fragment namespace (NS) that that 'executeOn'
belongs to.
* *name*: The name of the rule to be applied. This is a
link:#composite-rule-name[Composite Rule Name] that references a
ruleBase and ruleName combination in a dot delimited format i.e.
"ruleBaseName.ruleName".
* *onFail*: The severity of a failed match for the Validation rule. See
link:#onfail[onFail] section for details.

An example of a Validation rule configuratio0n would be as follows:

[source,xml]
----
<validation:rule executeOn="order/header/email" name="regexAddressing.email" onFail="ERROR" />
----

===== Configuring Max Failures

One can set a maximum number of validation failures per Smooks filter
operation. An exception will be thrown if this max value is exceeded.
Note that validations configured with *OnFail.FATAL* will always throw
an exception and stop processing.

To configure the maximum validation failures add this following to you
Smooks configuration:

[source,xml]
----
<params>  
    <param name="validation.maxFails">5</param>  
</params>
----

===== onFail

The onFail attribute in the validation configuration specified what
action should be taken when a rule matches. This is all about reporting
back valdiation failures.

The following options are available:

* *OK'*: Save the validation as an ok validation. Calling
ValidationResults.getOks will return all validation warnings. This can
be useful for content based routing.
* *WARN*: Save the validation as a warning. Calling
ValidationResults.getWarnings will return all validation warnings.
* *ERROR*: Save the validation as an error. Calling
ValidationResults.getErrors will return all validation errors.
* *FATAL*: Will throw a ValidationException as soon as a validation
failure occurs. Calling ValidationResults.getFatal will return the fatal
validation failure.

===== Composite Rule Name

When a RuleBase is references in Smooks you use a composite rule name in
the following format:

[source,xml]
----
<ruleProviderName>.<ruleName>
----

'*ruleProviderName'* Identifies the rule provider and maps to the 'name'
attribute in the 'ruleBase' element.

'*ruleName'* Identifies a specific rule the rule provider knows about.
This could be a rule defined in the 'src' file/resource.

==== Validation Results

Validation results are captured by the Smooks.filterSource by specifying
a ValidationResult instance in the filterSource method call. When the
filterSource method returns, the ValidationResult instance will contain
all validation data.

An example of executing Smooks in order to perform message fragment
validation is as follows:

[source,java]
----
ValidationResult validationResult = new ValidationResult();  

smooks.filterSource(new StreamSource(messageInStream), new StreamResult(messageOutStream), validationResult);  

List<OnFailResult> errors = validationResult.getErrors();  
List<OnFailResult> warnings = validationResult.getWarnings();
----

As you can see from the above code, individual warning, error etc
validation results are made available from the ValidationResult object
in the form of *OnFailResult* instances. The OnFailResult object
provides details about an individual failure.

==== Localized Validation Messages

The Validation Cartridge provides support for specifying localized
messages relating to Validation failures. These messages can be defined
in standard Java ResourceBundle files (.properties format). A convention
is used here, based on the rule source name ("src"). The validation
message bundle base name is derived from the rule source ("src") by
dropping the rule source file extension and adding an extra folder named
"i18n" e.g. for an MVEL ruleBase source of
"/org/smooks/validation/order/rules/order-rules.csv", the corresponding
validation message bundle base name would be
"/org/smooks/validation/order/rules/i18n/order-rules".

The validation cartridge supports application of *FreeMarker templates*
on the localized messages, allowing the messages to contain contextual
data from the bean context, as well as data about the actual rule
failure. FreeMarker based messages must be prefixed with "ftl:" and the
contextual data is references using the normal FreeMarker notation. The
beans from the bean context can be referenced directly, while the
RuleEvalResult and rule failure path can be referenced through the
"ruleResult" and "path" beans.

Example message using RegexProvider rules:

....
customerId=ftl:Invalid customer number '${ruleResult.text}' at '${path}'.  Customer number must match pattern '${ruleResult.pattern}'.
....

==== Example

https://github.com/smooks/smooks/tree/v1.7.1/smooks-examples/validation-basic[See
the Validation Example].


=== Templating

include::https://raw.githubusercontent.com/smooks/smooks-templating-cartridge/master/README.adoc[tag=smooks-templating-cartridge,leveloffset=2]

=== Pipeline

A pipeline is a flexible, yet simple, Smooks construct that isolates the
processing of a targeted event from its main processing as well as from
the processing of other pipelines. In practice, this means being able to
compose any series of transformations on an event outside the main
execution context before directing the pipeline output to the execution
result stream or to other destinations. With pipelines, you can enrich
data, rename/remove elements or attributes, and much more.

Under the hood, a pipeline is just another instance of Smooks, made
self-evident from the Smooks config element declaring a pipeline:

[source,xml]
----
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"
                      xmlns:core="https://www.smooks.org/xsd/smooks/smooks-core-1.6.xsd">

   <core:smooks filterSourceOn="...">
       <core:action>
           ...
       </core:action>
       <core:config>
           <smooks-resource-list>
               ...
           </smooks-resource-list>
       </core:config>
   </core:smooks>

</smooks-resource-list>
----

_core:smooks_ fires a nested Smooks execution whenever an event in the
stream matches the _filterSourceOn_ selector. The pipeline within the
inner _smooks-resource-list_ element visits the selected event and its
child events. It is worth highlighting that the inner
_smooks-resource-list_ element behaves identically to the outer one, and
therefore, it accepts resources like visitors, readers, and even
pipelines (a pipeline within a pipeline!). Moreover, a pipeline is
transparent to its nested resources: a resource’s behaviour remains the
same whether it’s declared inside a pipeline or outside it.

The optional _core:action_ element tells the nested Smooks instance what
to do with the pipeline’s output. The next sections list the supported
actions.

==== Inline

Merges the pipeline's output with the result stream. Config Example:

[source,xml]
----
...
<core:action>
    <core:inline>
        ...
    </core:inline>
</core:action>
...
----

As described in the subsequent sections, an inline action replaces,
prepends, or appends content.

===== Replace

Substitutes the selected fragment with the pipeline output:

[source,xml]
----
...
<core:inline>
    <core:replace/>  
</core:inline>
...
----

===== Prepend Before

Adds the output before the selector start tag:

[source,xml]
----
<core:inline>
    <core:prepend-before/>  
</core:inline>
----

===== Prepend After

Adds the output after the selector start tag:

[source,xml]
----
<core:inline>
    <core:prepend-after/>  
</core:inline>
----

===== Append Before

Adds the output before the selector end tag:

[source,xml]
----
<core:inline>
    <core:append-before/>  
</core:inline>
----

===== Append After

Adds the output after the selector end tag:

[source,xml]
----
<core:inline>
    <core:append-after/>  
</core:inline>
----

==== Bind To

Binds the output to the execution context’s bean store:

[source,xml]
----
...
<core:action>
    <core:bind-to id="..."/>
</core:action>
...
----

==== Output To

Directs the output to a different stream other than the result stream:

[source,xml]
----
...
<core:action>
    <core:output-to outputStreamResource="..."/>
</core:action>
...
----

=== Exporting Results

When using Smooks standalone you are in full control of the type of
output that Smooks produces since you specify it by passing a certain
Result to the filter method. But when integrating Smooks with other
frameworks (JBossESB, Mule, Camel, and others) this needs to be
specified inside the framework's configuration. Starting with version
1.4 of Smooks you can now declare the data types that Smooks produces
and you can use the Smooks api to retrieve the Result(s) that Smooks
exports.

To declare the type of result that Smooks produces you use the 'exports'
element as shown below:

[source,xml]
----
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd" xmlns:core="https://www.smooks.org/xsd/smooks/smooks-core-1.6.xsd">  
   <core:exports>  
      <core:result type="org.smooks.io.payload.JavaResult"/>  
   </core:exports>  
</smooks-resource-list>
----

The newly added exports element declares the results that are produced
by this Smooks configuration. A exports element can contain one or more
result elements. A framework that uses Smooks could then perform
filtering like this:

[source,java]
----
// Get the Exported types that were configured.  
Exports exports = Exports.getExports(smooks.getApplicationContext());  
if (exports.hasExports())  
{  
    // Create the instances of the Result types.  
    // (Only the types, i.e the Class type are declared in the 'type' attribute.  
    Result[] results = exports.createResults();  
    smooks.filterSource(executionContext, getSource(exchange), results);  
    // The Results(s) will now be populate by Smooks filtering process and  
    // available to the framework in question.  
}
----

There might also be cases where you only want a portion of the result
extracted and returned. You can use the ‘extract’ attribute to specify
this:

[source,xml]
----
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"
                      xmlns:core="https://www.smooks.org/xsd/smooks/smooks-core-1.6.xsd">  
   <core:exports>  
      <core:result type="org.smooks.io.payload.JavaResult" extract="orderBean"/>  
   </core:exports>  
</smooks-resource-list>
----

The extract attribute is intended to be used when you are only
interested in a sub-section of a produced result. In the example above
we are saying that we only want the object named orderBean to be
exported. The other contents of the JavaResult will be ignored. Another
example where you might want to use this kind of extracting could be
when you only want a ValidationResult of a certain type, for example to
only return validation errors.

Below is an example of using the extracts option from an embedded
framework:

[source,java]
----
// Get the Exported types that were configured.  
Exports exports = Exports.getExports(smooks.getApplicationContext());  
if (exports.hasExports())  
{  
    // Create the instances of the Result types.  
    // (Only the types, i.e the Class type are declared in the 'type' attribute.  
    Result[] results = exports.createResults();  
    smooks.filterSource(executionContext, getSource(exchange), results);  
    List<object> objects = Exports.extractResults(results, exports);  
    // Now make the object available to the framework that this code is running:  
    // Camel, JBossESB, Mule, etc...
}
----

== Enriching Output Data

There are three out-of-the-box methods for enriching your output data:

* Use a JDBC Datasource to access a database and use SQL statements to
read from and write to the database. This capability is provided through
the Smooks Routing Cartridge. See the section on
link:#routing-to-a-database-using-sql[Routing to a Database using SQL].
* Use an entity persistence framework (like MyBatis, Hibernate or any
JPA compatible framework) to access a database and use its query
language or CRUD methods to read from it or write to it. See the section
on link:#entity-persistence-frameworks[Entity Persistence Frameworks].
* Use custom Data Access Objects (DAO's) to access a database and use
it's CRUD methods to read from it or write to it. Again, see
link:#DAO_Support[DAO Support].

*Note*: _Be sure to read the section on link:#java-binding[Java
Binding]_.

TODO: Rewrite / restructure this chapter

=== SQL Support

See the link:#routing-to-a-database-using-sql[Routing to a Database
using SQL] chapter for more information.

TODO: Write this chapter

=== Entity Persistence Frameworks

With the new Smooks Persistence cartridge in Smooks 1.2, you can
directly use several entity persistence frameworks from within Smooks
(Hibernate, JPA, etc...).

Lets take a look at a Hibernate example. The same principals follow for
any JPA compliant framework.

The data we are going to process is an XML order message. It should be
noted however, that the input data could also be CSV, JSON, EDI, Java or
any other structured/hierarchical data format. The same principals
apply, no matter what the data format is!

[source,xml]
----
<order>  
    <ordernumber>1</ordernumber>  
    <customer>123456</customer>  
    <order-items>  
        <order-item>  
            <product>11</product>  
            <quantity>2</quantity>  
        </order-item>  
        <order-item>  
            <product>22</product>  
            <quantity>7</quantity>  
        </order-item>  
    </order-items>  
</order>
----

The Hibernate entities are:

[source,java]
----
@Entity
@Table(name="orders")
public class Order {

    @Id
    private Integer ordernumber;

    @Basic
    private String customerId;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL)
    private List orderItems = new ArrayList();

    public void addOrderLine(OrderLine orderLine) {
        orderItems.add(orderLine);
    }

    // Getters and Setters....
}

@Entity
@Table(name="orderlines")
public class OrderLine {

    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Integer id;

    @ManyToOne
    @JoinColumn(name="orderid")
    private Order order;

    @Basic
    private Integer quantity;

    @ManyToOne
    @JoinColumn(name="productid")
    private Product product;

    // Getters and Setters....
}

@Entity
@Table(name = "products")
@NamedQuery(name="product.byId", query="from Product p where p.id = :id")
public class Product {

    @Id
    private Integer id;

    @Basic
    private String name;

    // Getters and Setters....
}
----

What we want to do here is to process and persist the . First thing we
need to do is to bind the order data into the Order entities (Order,
OrderLine and Product). To do this we need to:

. *Create* and populate the Order and OrderLine entities using the
link:#java-binding[Java Binding] framework.
. *Wire* each OrderLine instance into the Order instance.
. Into each OrderLine instance, we need to *lookup and wire* in the
associated order line Product entity.
. And finally, we need to *insert* (persist) the Order instance.

To do this, we need the following Smooks configuration:

[source,xml]
----
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"   
 xmlns:jb="https://www.smooks.org/xsd/smooks/javabean-1.6.xsd"   
 xmlns:dao="https://www.smooks.org/xsd/smooks/persistence-2.0.xsd">  

    <jb:bean beanId="order" class="example.entity.Order" createOnElement="order">  
        <jb:value property="ordernumber" data="ordernumber" />  
        <jb:value property="customerId" data="customer" />  
        <jb:wiring setterMethod="addOrderLine" beanIdRef="orderLine" />  
    </jb:bean>  

    <jb:bean beanId="orderLine" class="example.entity.OrderLine" createOnElement="order-item">  
        <jb:value property="quantity" data="quantity" />  
        <jb:wiring property="order" beanIdRef="order" />  
        <jb:wiring property="product" beanIdRef="product" />  
    </jb:bean>  

    <dao:locator beanId="product" lookupOnElement="order-item" onNoResult="EXCEPTION" uniqueResult="true">  
        <dao:query>from Product p where p.id = :id</dao:query>  
        <dao:params>  
            <dao:value name="id" data="product" decoder="Integer" />  
        </dao:params>  
    </dao:locator>  

    <dao:inserter beanId="order" insertOnElement="order" />  

</smooks-resource-list>
----

If we want to use the named query "productById" instead of the query
string then the DAO locator configuration will look like this:

[source,xml]
----
<dao:locator beanId="product" lookupOnElement="order-item" lookup="product.byId" onNoResult="EXCEPTION" uniqueResult="true">  
    <dao:params>  
        <dao:value name="id" data="product" decoder="Integer"/>  
    </dao:params>  
</dao:locator>
----

The following code executes Smooks. Note that we use a SessionRegister
object so that we can access the Hibernate Session from within Smooks.

[source,java]
----
Smooks smooks = new Smooks("smooks-config.xml");  

ExecutionContext executionContext = smooks.createExecutionContext();  

// The SessionRegister provides the bridge between Hibernate and the  
// Persistence Cartridge. We provide it with the Hibernate session.  
// The Hibernate Session is set as default Session.  
DaoRegister register = new SessionRegister(session);  

// This sets the DAO Register in the executionContext for Smooks  
// to access it.  
PersistenceUtil.setDAORegister(executionContext, register);  

Transaction transaction = session.beginTransaction();  

smooks.filterSource(executionContext, source);  

transaction.commit();
----

=== Data Access Object Support

Now let’s take a look at a DAO based example. The example will read an
XML file containing order information (note that this works just the
same for EDI, CSV, etc...). Using the javabean cartridge, it will bind
the XML data into a set of entity beans. Using the id of the products
within the order items (the element) it will locate the product entities
and bind them to the order entity bean. Finally, the order bean will be
persisted.

The order XML message looks like this:

[source,xml]
----
<order>  
    <ordernumber>1</ordernumber>  
    <customer>123456</customer>  
    <order-items>  
        <order-item>  
            <product>11</product>  
            <quantity>2</quantity>  
        </order-item>  
        <order-item>  
            <product>22</product>  
            <quantity>7</quantity>  
        </order-item>  
    </order-items>  
</order>
----

The following custom DAO will be used to persist the Order entity:

[source,java]
----
@Dao  
public class OrderDao {  

    private final EntityManager em;  

    public OrderDao(EntityManager em) {  
        this.em = em;  
    }  

    @Insert  
    public void insertOrder(Order order) {  
        em.persist(order);  
    }  
}
----

When looking at this class you should notice the @Dao and @Insert
annotations. The @Dao annotation declares that the OrderDao is a DAO
object. The @Insert annotation declares that the insertOrder method
should be used to insert Order entities.

The following custom DAO will be used to lookup the Product entities:

[source,java]
----
@Dao  
public class ProductDao {  

    private final EntityManager em;  

    public ProductDao(EntityManager em) {  
        this.em = em;  
    }  

    @Lookup(name = "id")  
    public Product findProductById(@Param("id")int id) {  
        return em.find(Product.class, id);  
    }  
}
----

When looking at this class, you should notice the @Lookup and @Param
annotation. The @Lookup annotation declares that the
ProductDao#findByProductId method is used to lookup Product entities.
The name parameter in the @Lookup annotation sets the lookup name
reference for that method. When the name isn’t declared, the method name
will be used. The optional @Param annotation let’s you name the
parameters. This creates a better abstraction between Smooks and the
DAO. If you don’t declare the @Param annotation the parameters are
resolved by there position.

The Smooks configuration look likes this:

[source,xml]
----
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"  
                      xmlns:jb="https://www.smooks.org/xsd/smooks/javabean-1.6.xsd"  
                      xmlns:dao="https://www.smooks.org/xsd/smooks/persistence-2.0.xsd">  

    <jb:bean beanId="order" class="example.entity.Order" createOnElement="order">  
        <jb:value property="ordernumber" data="ordernumber"/>  
        <jb:value property="customerId" data="customer"/>  
        <jb:wiring setterMethod="addOrderLine" beanIdRef="orderLine"/>  
    </jb:bean>  

    <jb:bean beanId="orderLine" class="example.entity.OrderLine" createOnElement="order-item">  
        <jb:value property="quantity" data="quantity"/>  
        <jb:wiring property="order" beanIdRef="order"/>  
        <jb:wiring property="product" beanIdRef="product"/>  
    </jb:bean>  

    <dao:locator beanId="product" dao="product" lookup="id" lookupOnElement="order-item" onNoResult="EXCEPTION">  
        <dao:params>  
            <dao:value name="id" data="product" decoder="Integer"/>  
        </dao:params>  
    </dao:locator>  

    <dao:inserter beanId="order" dao="order" insertOnElement="order"/>  

</smooks-resource-list>
----

The following code executes Smooks:

[source,java]
----
Smooks smooks=new Smooks("./smooks-configs/smooks-dao-config.xml");  
ExecutionContext executionContext=smooks.createExecutionContext();  

// The register is used to map the DAO's to a DAO name. The DAO name isbe used in  
// the configuration.  
// The MapRegister is a simple Map like implementation of the DaoRegister.  
DaoRegister<object>register = MapRegister.builder()  
        .put("product",new ProductDao(em))  
        .put("order",new OrderDao(em))  
        .build();  

PersistenceUtil.setDAORegister(executionContext,mapRegister);  

// Transaction management from within Smooks isn't supported yet,  
// so we need to do it outside the filter execution  
EntityTransaction tx=em.getTransaction();  
tx.begin();  

smooks.filter(new StreamSource(messageIn),null,executionContext);  

tx.commit();
----

== Scripting

=== Groovy

Support for https://groovy-lang.org/[Groovy] based scripting is made
available through the https://www.smooks.org/xsd/smooks/groovy-2.0.xsd
configuration namespace. This adds support for DOM or SAX based Groovy
scripting.

Example configuration:

[source,xml]
----
<?xml version="1.0"?>  
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"
                      xmlns:g="https://www.smooks.org/xsd/smooks/groovy-2.0.xsd">  

    <g:groovy executeOnElement="xxx">  
        <g:script>  
        <!--  
 //Rename the target fragment element from "xxx" to "yyy"...  
 DomUtils.renameElement(element, "yyy", true, true);  
 -->  
        </g:script>  
    </g:groovy>  

</smooks-resource-list>
----

*Usage Tips*

. *Imports*: Imports can be added via the "imports" element. A number of
classes are automatically imported:
* org.smooks.support.DomUtils
* org.smooks.api.bean.context.BeanContext
* org.smooks.api.bean.repository.BeanRepository
* org.w3c.dom.*
* groovy.xml.dom.DOMCategory, groovy.xml.dom.DOMUtil,
groovy.xml.DOMBuilder
. *Visited Element*: The visited element is available to the script
through the variable "*element*". It is also available under a variable
name equal to the element name, but only if the element name contains
alpha-numeric characters only.
. *Execute Before/After*: By default, the script is executed on the
visitAfter event. You can direct it to be executed on the visitBefore by
setting the "*executeBefore*" attribute to "true".
. *Comment/CDATA Script Wrapping*: If the script contains special XML
characters, it can be wrapped in an XML Comment or CDATA section.

==== Groovy Scriptlet Variables and Methods

A number of variables and methods are made directly available to groovy
scriptlet code i.e. you can references them directly in your scriptlet.

_*Variables*_:

* *element*: The DOM/SAX Element (depending on which filter type is in
use) i.e. _org.w3c.dom.Element_ or
_org.api.smooks.delivery.sax.SAXElement_.
* *executionContext*: The Smooks _ExecutionContext_ instance associated
with the Smooks filtering operation.
* *nodeModels*: A Map containing all the DOM NodeModels currently
available (i.e. Map<String, Element>).

_*Methods*_:

* *Object getBean(String beanId)*: Get a bean from the _BeanContext_.

==== Adding Beans to the BeanContext

As shown above, all scriptlet code can access the beans in the
_BeanContext_ by calling the _getBean_ method from inside the scriptlet
code. One oversight when implementing this feature was that we didn't
provide an _addBean_ method for adding beans to the bean context.
However, it is still possible to do so in a slightly more longwinded
method via the _executionContext_ e.g.:

executionContext.getBeanContext().addBean("myBean", myBeanInstance);

==== Mixed DOM and SAX with Groovy

Because https://groovy-lang.org/[Groovy] has a number of very useful DOM
processing features, we added support for the mixed DOM and SAX
processing models.

What this means is that you can use Groovy's DOM utilities to process
the targeted message fragment. The "*element*" received by the Groovy
script will be a DOM Element, even when using the SAX filter. This makes
Groovy scripting via the SAX filter a lot easier, while at the same time
maintaining the ability to process huge messages in a streamed fashion.

*Mixed SAX and DOM Gotchas*

* Only available in default mode i.e. when "*executeBefore*" equals
"*false*". If "*executeBefore*" is configured "*true*", this facility is
not available and the Groovy script will only have access to the element
as a SAXElement.
* To write the DOM fragment to a Smooks.filterSource StreamResult,
"writeFragment" must be called. See example below.
* There is an obvious performance overhead incurred using this facility
(DOM construction). That said, it can still be used to process huge
messages because of how the link:#mixing-dom-and-sax[DomModelCreator]
works for SAX. So, it can still process huge message, but it might take
a little longer. The tradeoff is usability Vs performance.

==== Mixed DOM and SAX Example

Take an XML message such as:

[source,xml]
----
<shopping>  
    <category type="groceries">  
        <item>Chocolate</item>  
        <item>Coffee</item>  
    </category>  
    <category type="supplies">  
        <item>Paper</item>  
        <item quantity="4">Pens</item>  
    </category>  
        <category type="present">  
        <item when="Aug 10">Kathryn's Birthday</item>  
    </category>  
</shopping>
----

Using Groovy, we want to modify the "supplies" category in the shopping
list, adding 2 to the quantity, where the item is "Pens". To do this, we
write a simple little Groovy script and target it at the elements in the
message. The script simple iterates over the elements in the category
and increments the quantity by 2, where the category type is "supplies"
and the item is "Pens":

[source,xml]
----
<?xml version="1.0"?>
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"
                      xmlns:core="https://www.smooks.org/xsd/smooks/smooks-core-1.6.xsd"
                      xmlns:g="https://www.smooks.org/xsd/smooks/groovy-2.0.xsd">

    <core:filterSettings type="SAX" />

    <g:groovy executeOnElement="category">
        <g:script>
        <!--
        use(DOMCategory) {
            // Modify "supplies": we need an extra 2 pens...
            if (category.'@type' == 'supplies') {
                category.item.each { item ->
                    if (item.text() == 'Pens') {
                        item['@quantity'] = item.'@quantity'.toInteger() + 2;
                    }
                }
            }
        }

        // When using the SAX filter, we need to explicitly write the fragment
        // to the result stream...
        writeFragment(category);
        -->
        </g:script>
    </g:groovy>

</smooks-resource-list>
----

== Routing Output Data

Smooks supports a number of different options when it comes to Splitting
and Routing message fragments. The ability to split messages into
fragments and route these fragments to different kinds of endpoints
(File, JMS, etc...) is a very important capability. Smooks provides this
capability with a number of very interesting "twists":

. *Basic Fragment Splitting*: It is often the case that you simply need
to perform a dumb split on a message e.g. splitting all the fragments in
a message and route them to a file. When we say "dumb split", we mean
that you don't need to perform any type of transformation on the split
message fragments before routing such as merging data from other parts
of the message hierarchy before routing (e.g. add customer details info
to the fragment before routing). Basic splitting and routing simply
involves defining the XPath of the message fragment to be split out and
the defining a routing component (e.g. JBoss ESB or Camel) to route that
unmodified split message fragment. See
link:#basic-splitting-and-routing[Basic Splitting and Routing].
. *Complex Fragment Splitting*: Basic Fragment Splitting works for many
use cases and is what most Splitting and Routing solutions offer. Smooks
extends the basic splitting capabilities by allowing you to perform
transformations on the split fragment data before routing is applied
e.g. merging in the order information with each information before
performing the routing order-item split fragment routing.
. *In Stream Splitting & Routing (Huge Message Support)*: Because Smooks
can perform routing "in stream" (not batched up for routing after
processing the complete message), it is able to accommodate processing
of huge message streams (>> GBs).
. *Multiple Splitting and Routing*: Conditionally split and route
multiple message fragments (different formats XML, EDI, Java, etc...) to
different endpoints in a single filtering pass of the input message
stream e.g. route an OrderItem Java object instance to the
"HighValueOrdersValidation" JMS Queue for order items with a value
greater than $1,000 and route all order items (unconditional) as
XML/JSON to a HTTP endpoint for logging.

See the section on link:#splitting--routing[Splitting & Routing].

=== File

See the link:#routing-to-file[Routing to File] chapter for more
information.

=== Database

See the link:#enriching-output-data[Enriching Output Data] chapter for
more information on database access (also for writing to the database)

=== Java

See the link:#the-bean-context[Bean Context] chapter in th basics
chapter for more information.

=== JMS

See the link:#routing-to-jms[Routing to JMS] for more information.

=== ESB Support

Smooks plugins are available for a number of ESBs:

. http://wiki.jboss.org/wiki/Wiki.jsp?page=MessageTransformation[JBoss
ESB].
. http://www.mulesource.org/display/SMOOKS/Home[Mule].
. http://esbsite.org/resources.jsp?path=/mediators/upul/Smooks%20Transform%20Mediator[Apache
Synapse/WS02].

=== Camel

It is possible to route fragments to Apache Camel endpoints using the
*<https://www.smooks.org/xsd/smooks/camel-1.5.xsd[camel:route]>*
configuration from the https://www.smooks.org/xsd/smooks/camel-1.5.xsd
configuration namespace.

For example, you can route to Camel endpoint by specifying the following
in your Smooks configuration:

[source,xml]
----
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"
                      xmlns:camel="https://www.smooks.org/xsd/smooks/camel-1.5.xsd">  

  <!-- Create some bean instances from the input source... -->  
  <jb:bean beanId="orderItem"  ...>  
    <!-- etc... See Smooks Java Binding docs -->  
  </jb:bean>  

  <!-- Route bean to camel endpoints... -->  
  <camel:route beanid="orderItem">  
    <camel:to endpoint="direct:slow" if="orderItem.priority == 'Normal'" />  
    <camel:to endpoint="direct:express" if="orderItem.priority == 'High'" />  
  </camel:route>  

</smooks-resource-list>
----

In the above example, we route Java Beans from the Smooks BeanContext to
the Camel Endpoints. Note that you can also apply templates (e.g.
FreeMarker) to these same beans and route the templating result instead
of beans (e.g. as XML, CSV or other).

The above configuration shows routing using the ‘beanId’ attribute. It
is also possible to route using an attribute named ‘routeOnElement'

== Performance Tuning

Like with any Software, when configured or used incorrectly, performance
can be one of the first things to suffer. Smooks is no different in this
regard.

=== General

* *Cache and Reuse* the Smooks Object. Initialization of Smooks takes
some time and therefore it is important that it is reused.
* *link:#filter-settings[Pool reader instances]* where possible. This
can result in a huge performance boost, as some readers are very
expensive to create.
* *If possible, use link:#filter-settings[SAX filtering]*. However, you
need to check that all Smooks Cartridges in use are SAX compatible. SAX
processing is a lot faster than DOM processing and has a consistently
small memory footprint. It is mandatory for processing large messages.
See the link:#filtering-process-selection-dom-or-sax[Filtering Process
Selection (DOM or SAX?)] section. SAX filtering is the
http://jira.codehaus.org/browse/MILYN-589[default filtering type since
Smooks v1.5].
* *Turn off debug logging*. Smooks performs some intensive debug logging
in parts of the code. This can result in significant additional
processing overhead and lower throughput. Also remember that NOT having
your logging configured (at all) may result in debug log statements
being executed!!
* *Only use the HTMLReportGenerator in development*. When enabled, the
HTMLReportGenerator incurs a significant performance overhead and with
large message, can even result in OutOfMemory exceptions.
* *Contextual selectors* can obviously have a negative effect on
performance e.g. evaluating a match for a selector like "a/b/c/d/e" will
obviously require more processing than that of a selector like "d/e".
Obviously there will be situations where your data model will require
deep selectors, but where it does not, you should try to optimize them
for the sake of performance.

=== Smooks Cartridges

Every cartridge can have its own performance optimization tips.

=== Javabean Cartridge

* If possible don't use the Virtual Bean Model. Create Beans instead of
maps. Creating and adding data to Maps is a lot slower then creating
simple POJO's and calling the setter methods.

== Testing

=== Unit Testing

Unit testing with Smooks is simple:

[source,java]
----
public class MyMessageTransformTest {  
    @Test  
    public void test_transform() throws Exception {
        Smooks smooks = new Smooks(getClass().getResourceAsStream("smooks-config.xml"));  

        try {  
            Source source = new StreamSource(getClass().getResourceAsStream("input-message.xml" ) );  
            StringResult result = new StringResult();  

            smooks.filterSource(source, result);  

            // compare the expected xml with the transformation result.  
            XMLUnit.setIgnoreWhitespace(true);  
            XMLAssert.assertXMLEqual(new InputStreamReader(getClass().getResourceAsStream("expected.xml")), new StringReader(result.getResult()));        
        } finally {  
            smooks.close();  
        }  
    }  
}
----

The test case above uses https://www.xmlunit.org/[xmlunit].

The following maven dependency was used for xmlunit in the above test:

[source,xml]
----
<dependency>  
    <groupId>xmlunit</groupId>  
    <artifactId>xmlunit</artifactId>  
    <version>1.1</version>  
</dependency>
----

== Common use cases

=== Processing Huge Messages (GBs)

One of the main features introduced in Smooks v1.0 is the ability to
process huge messages (Gbs in size). Smooks supports the following types
of processing for huge messages:

* *One-to-One Transformation*: This is the process of transforming a
huge message from its source format (e.g. XML), to a huge message in a
target format e.g. EDI, CSV, XML etc.
* *Splitting & Routing*: Splitting of a huge message into smaller (more
consumable) messages in any format (EDI, XML, Java, etc...) and
*Routing* of those smaller messages to a number of different destination
types (filesystem, JMS, database).
* *Persistence*: Persisting the components of the huge message to a
database, from where they can be more easily queried and processed.
Within Smooks, we consider this to be a form of Splitting and Routing
(routing to a database).

All of the above is possible without writing any code (i.e. in a
declarative manner). Typically, any of the above types of processing
would have required writing quite a bit of ugly/unmaintainable code. It
might also have been implemented as a multi-stage process where the huge
message is split into smaller messages (stage #1) and then each smaller
message is processed in turn to persist, route, etc... (stage #2). This
would all be done in an effort to make that ugly/unmaintainable code a
little more maintainable and reusable. With Smooks, most of these
use-cases can be handled without writing any code. As well as that, they
can also be handled in a single pass over the source message, splitting
and routing in parallel (plus routing to multiple destinations of
different types and in different formats).

*Note*: _Be sure to read the section on link:#java-binding[Java
Binding]_.

*Performance Hint*

* When processing huge messages with Smooks, make sure you are using the
*SAX NG filter*.

==== One-to-One Transformation

If the requirement is to process a huge message by transforming it into
a single message of another format, the easiest mechanism with Smooks is
to apply multiple FreeMarker templates to the Source message Event
Stream, outputting to a Smooks.filterSource Result stream.

This can be done in one of 2 ways with FreeMarker templating, depending
on the type of model that's appropriate:

. Using FreeMarker + NodeModels for the model.
. Using FreeMarker + a Java Object model for the model. The model can be
constructed from data in the message, using the Javabean Cartridge.

Option #1 above is obviously the option of choice, if the tradeoffs are
OK for your use case. Please see the FreeMarker Templating docs for more
details.

The following images shows an message, as well as the message to which
we need to transform the message:

image:../assets/images/Huge-message.png[Image:huge-message.png]

Imagine a situation where the message contains millions of elements.
Processing a huge message in this way with Smooks and FreeMarker (using
NodeModels) is quite straightforward. Because the message is huge, we
need to identify multiple NodeModels in the message, such that the
runtime memory footprint is as low as possible. We cannot process the
message using a single model, as the full message is just too big to
hold in memory. In the case of the message, there are 2 models, one for
the main data (blue highlight) and one for the data (beige highlight):

image:../assets/images/Huge-message-models.png[Image:huge-message-models.png]

So in this case, the most data that will be in memory at any one time is
the main order data, plus one of the order-items. Because the NodeModels
are nested, Smooks makes sure that the order data NodeModel never
contains any of the data from the order-item NodeModels. Also, as Smooks
filters the message, the order-item NodeModel will be overwritten for
every order-item (i.e. they are not collected). See link:#sax-ng[SAX
NG].

Configuring Smooks to capture multiple NodeModels for use by the
FreeMarker templates is just a matter of configuring the
*DomModelCreator* visitor, targeting it at the root node of each of the
models. Note again that Smooks also makes this available to SAX
filtering (the key to processing huge message). The Smooks configuration
for creating the NodeModels for this message are:

[source,xml]
----
<?xml version="1.0"?>  
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"   
                      xmlns:core="https://www.smooks.org/xsd/smooks/smooks-core-1.6.xsd"  
                      xmlns:ftl="https://www.smooks.org/xsd/smooks/freemarker-2.0.xsd">   

     <!--  
        Create 2 NodeModels. One high level model for the "order"  
        (header, etc...) and then one for the "order-item" elements...  
     -->  
    <resource-config selector="order,order-item">  
        <resource>org.smooks.engine.resource.visitor.dom.DomModelCreator</resource>  
    </resource-config>  

    <!-- FreeMarker templating configs to be added below... -->
----

Now the FreeMarker templates need to be added. We need to apply 3
templates in total:

. A template to output the order "header" details, up to but not
including the order items.
. A template for each of the order items, to generate the elements in
the .
. A template to close out the message.

With Smooks, we implement this by defining 2 FreeMarker templates. One
to cover #1 and #3 (combined) above, and a seconds to cover the
elements.

The first FreeMarker template is targeted at the element and looks as
follows:

[source,xml]
----
<ftl:freemarker applyOnElement="order-items">
        <ftl:template><!--<salesorder>
    <details>
        <orderid>${order.@id}</orderid>
        <customer>
            <id>${order.header.customer.@number}</id>
            <name>${order.header.customer}</name>
        </customer>
    </details>
    <itemList>
    <?TEMPLATE-SPLIT-PI?>
    </itemList>
</salesorder>-->
        </ftl:template>
</ftl:freemarker>
----

You will notice the *<?TEMPLATE-SPLIT-PI?>* Processing Instruction. This
tells Smooks where to split the template, outputting the first part of
the template at the start of the element, and the other part at the end
of the element. The element template (the second template) will be
output in between.

The second FreeMarker template is very straightforward. It simply
outputs the elements at the end of every element in the source message:

[source,xml]
----
    <ftl:freemarker applyOnElement="order-item">
        <ftl:template><!-- <item>
    <id>${.vars["order-item"].@id}</id>
    <productId>${.vars["order-item"].product}</productId>
    <quantity>${.vars["order-item"].quantity}</quantity>
    <price>${.vars["order-item"].price}</price>
</item>-->
        </ftl:template>
    </ftl:freemarker>
</smooks-resource-list>
----

Because the second template fires on the end of the elements, it
effectively generates output into the location of the
*<?TEMPLATE-SPLIT-PI?>* Processing Instruction in the first template.
Note that the second template could have also referenced data in the
"order" NodeModel.

And that's it! This is available as a runnable example in the Tutorials
section.

This approach to performing a One-to-One Transformation of a huge
message works simply because the only objects in memory at any one time
are the order header details and the current details (in the Virtual
Object Model).? Obviously it can't work if the transformation is so
obscure as to always require full access to all the data in the source
message e.g. if the messages needs to have all the order items reversed
in order (or sorted).? In such a case however, you do have the option of
routing the order details and items to a database and then using the
database's storage, query and paging features to perform the
transformation.

==== Splitting & Routing

Another common approach to processing large/huge messages is to split
them out into smaller messages that can be processed independently. Of
course Splitting and Routing is not just a solution for processing huge
messages. It's often needed with smaller messages too (message size may
be irrelevant) where, for example, order items in an an order message
need to be split out and routed (based on content - "Content Base
Routing") to different departments or partners for processing. Under
these conditions, the message formats required at the different
destinations may also vary e.g.

* "destination1" required XML via the file system,
* "destination2" requires Java objects via a JMS Queue,
* "destination3" picks the messages up from a table in a database,
etc...
* "destination4" requires EDI messages via a JMS Queue,
* etc etc

With Smooks, all of the above is possible. You can perform multiple
splitting and routing operations to multiple destinations (of different
types) in a single pass over a message.

The basic concept is simple. As you stream the message through Smooks:

. Repeatedly create a standalone message (split) for the fragment to be
routed.
. Repeatedly bind the split message into the bean context under a unique
beanId.
. Repeatedly route the split message to the required endpoint (File, DB,
JMS, ESB).

We emphasize "Repeatedly" (above) so as to reinforce the point that
these operations happen for each instance of the split message found in
the source message e.g. for each in an message.

As for points #1 and #2 above specifically, Smooks offers to approaches
to creating the split messages:

. A basic (untransformed/unenriched) fragment split and bind. This is a
very simple configuration that simply serializes a message fragment
(repeatedly) to its XML form and stores it in the bean context as a
String.
. A more complex approach using the Java Binding and Templating
Cartridges, where you configure Smooks to extract data from the source
message and and into the bean context (using configs) and then
(optionally) apply templates to create the split messages. This is more
complex, but offers the following advantages:
* Allows for transformation of the split fragments i.e. not just XML as
with the basic option.
* Allows for enrichment of the message.
* Allows for more complex splits, with the ability to merge data from
multiple source fragments into each split message e.g. not just the
fragments, but the order
+
+
info too.
* Allows for splitting and routing of Java Objects as the Split messages
(e.g. over JMS).

With the more complex approach outlined above, the key to processing
huge messages (not an issue for the more basic approach) is to make sure
that you always maintain a small memory footprint. You can do this using
the Javabean Cartridge by making sure you're only binding the most
relevant message data (into the bean context) at any one time. In the
following sections, the examples are all based on splitting and routing
of order-items out of an order message. The solutions shown all work for
huge messages because the Smooks Javabean Cartridge binding
configurations are implemented such that the only data held in memory at
any given time is the main order details (order header etc) and the
"current" order item details.

===== Basic Splitting and Routing

As stated above, the easiest way to split and route fragments of a
message is to use the basic <frag:serialize> and <*:router> components
(<jms:router>, <file:router>, etc...) from the Routing Cartridge. The
<frag:serialize> component has its own configuration in the
https://www.smooks.org/xsd/smooks/fragment-routing-1.5.xsd namespace.

The following is an example for serializing the contents of a SOAP
message body and storing it in the Bean Context under the beanId of
"soapBody":

[source,xml]
----
<?xml version="1.0"?>  
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"
                      xmlns:frag="https://www.smooks.org/xsd/smooks/fragment-routing-1.5.xsd">  

    <frag:serialize fragment="Envelope/Body" bindTo="soapBody" childContentOnly="true"/>  

</smooks-resource-list>
----

Then the Smooks code for executing this:

[source,java]
----
Smooks smooks = new Smooks(configStream);  
JavaResult javaResult = new JavaResult();  

smooks.filterSource(new StreamSource(soapMessageStream), javaResult);  

String bodyContent = javaResult.getBean("soapBody").toString().trim();
----

And of course, you can do all of this programmatically too (i.e. no need
for the XML config):

[source,java]
----
Smooks smooks = new Smooks();  

smooks.addVisitor(new FragmentSerializer().setBindTo("soapBody"), "Envelope/Body");  

JavaResult javaResult = new JavaResult();  
smooks.filterSource(new StreamSource(soapMessageStream), javaResult);  

String bodyContent = javaResult.getBean("soapBody").toString().trim();
----

The code snippets above only show how to create the split messages and
bind them into the bean context, from where they can be accessed. How
about routing these split messages to another endpoint for processing?
Well it's easy, just use one of the routing components as outlined in
the following sections.

The following is a quick example, showing the config for routing split
messages (this time fragments) to a JMS Destination for processing:

[source,xml]
----
<?xml version="1.0"?>  
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"
                      xmlns:frag="https://www.smooks.org/xsd/smooks/fragment-routing-1.5.xsd" xmlns:jms="https://www.smooks.org/xsd/smooks/jms-routing-2.0.xsd">  

    <!-- Create the split messages for the order items... -->  
    <frag:serialize fragment="order-items/order-item" bindTo="orderItem" />  

    <!-- Route each order items split mesage to the orderItem JMS processing queue... -->  
    <jms:router routeOnElement="order-items/order-item" beanId="orderItem" destination="orderItemProcessingQueue" />  

</smooks-resource-list>
----

For more details on the JMS routing aspects of the above example, see
the JMS Router documentation (below). The <jms:router> could be
substituted for any of the other routers e.g. if using with JBoss ESB,
you could use the <esbr:routeBean> configuration to route the split
message to any ESB endpoint.

===== Routing to File

File based routing is performed via the the *<file:outputStream>*
configuration from the
https://www.smooks.org/xsd/smooks/file-routing-2.0.xsd configuration
namespace.

This section illustrates how you can combine the following Smooks
functionality to split a message out into smaller messages on the file
system.

. The *Javabean Cartridge* for extracting data from the message and
holding it in variables in the bean context. In this case, we could also
use DOM NodeModels for capturing the order and order-item data to be
used as the templating data models.
. The *<file:outputStream>* configuration from the *Routing Cartridge*
for managing file system streams (naming, opening, closing, throttling
creation, etc...).
. The *Templating Cartridge* (FreeMarker Templates) for generating the
individual split messages from data bound in the bean context by the
Javabean Cartridge (see #1 above). The templating result is written to
the file output stream (#2 above).

In the example, we want to process a huge order message and route the
individual order item details to file. The following illustrates what we
want to achieve. As you can see, the split messages don't just contain
data from the order item fragments. They also contain data from the
order header and root elements.

image:../assets/images/File-split-required.png[Image:file-split-required.png]

To achieve this with Smooks, we assemble the following Smooks
configuration:

[source,xml]
----
<?xml version="1.0"?>  
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"  
                      xmlns:core="https://www.smooks.org/xsd/smooks/smooks-core-1.6.xsd"  
                      xmlns:jb="https://www.smooks.org/xsd/smooks/javabean-1.6.xsd"  
                      xmlns:file="https://www.smooks.org/xsd/smooks/file-routing-2.0.xsd"  
                      xmlns:ftl="https://www.smooks.org/xsd/smooks/freemarker-2.0.xsd">  

        <!-- Extract and decode data from the message. Used in the freemarker template (below).  
             Note that we could also use a NodeModel here... -->  
(1)     <jb:bean beanId="order" class="java.util.Hashtable" createOnElement="order">  
            <jb:value property="orderId" decoder="Integer" data="order/@id"/>  
            <jb:value property="customerNumber" decoder="Long" data="header/customer/@number"/>  
            <jb:value property="customerName" data="header/customer"/>  
            <jb:wiring property="orderItem" beanIdRef="orderItem"/>  
        </jb:bean>  
(2)     <jb:bean beanId="orderItem" class="java.util.Hashtable" createOnElement="order-item">  
            <jb:value property="itemId" decoder="Integer" data="order-item/@id"/>  
            <jb:value property="productId" decoder="Long" data="order-item/product"/>  
            <jb:value property="quantity" decoder="Integer" data="order-item/quantity"/>  
            <jb:value property="price" decoder="Double" data="order-item/price"/>  
        </jb:bean>  

        <!-- Create/open a file output stream. This is writen to by the freemarker template (below).. -->  
(3)     <file:outputStream openOnElement="order-item" resourceName="orderItemSplitStream">  
            <file:fileNamePattern>order-${order.orderId}-${order.orderItem.itemId}.xml</file:fileNamePattern>  
            <file:destinationDirectoryPattern>target/orders</file:destinationDirectoryPattern>  
            <file:listFileNamePattern>order-${order.orderId}.lst</file:listFileNamePattern>  

            <file:highWaterMark mark="10"/>  
        </file:outputStream>  

        <!--  
         Every time we hit the end of an <order-item> element, apply this freemarker template,  
         outputting the result to the "orderItemSplitStream" OutputStream, which is the file  
         output stream configured above.  
        -->  
(4)     <ftl:freemarker applyOnElement="order-item">  
            <ftl:template>target/classes/orderitem-split.ftl</ftl:template>  
            <ftl:use>  
                <!-- Output the templating result to the "orderItemSplitStream" file output stream... -->  
                <ftl:outputTo outputStreamResource="orderItemSplitStream"/>  
            </ftl:use>  
        </ftl:freemarker>  

</smooks-resource-list>
----

Smooks Resource configuration #1 and #2 define the Java Bindings for
extracting the order header information (config #1) and the order-item
information (config #2). This is the key to processing a huge message;
making sure that we only have the current order item in memory at any
one time. The Smooks Javabean Cartridge manages all this for you,
creating and recreating the orderItem beans as the fragments are being
processed.

The *<file:outputStream>* configuration in configuration #3 manages the
generation of the files on the file system. As you can see from the
configuration, the file names can be dynamically constructed from data
in the bean context. You can also see that it can throttle the creation
of the files via the "highWaterMark" configuration parameter. This helps
you manage file creation so as not to overwhelm the target file system.

Smooks Resource configuration #4 defines the FreeMarker templating
resource used to write the split messages to the OutputStream created by
the file:outputStream (config #3). See how config #4 references the
file:outputStream resource. The Freemarker temaplte is as follows:

[source,java]
----
<orderitem id="${.vars["order-item"].@id}" order="${order.@id}">  
    <customer>  
        <name>${order.header.customer}</name>  
        <number>${order.header.customer.@number}</number>  
    </customer>  
    <details>  
        <productId>${.vars["order-item"].product}</productId>  
        <quantity>${.vars["order-item"].quantity}</quantity>  
        <price>${.vars["order-item"].price}</price>  
    </details>  
</orderitem>
----

===== Routing to JMS

JMS routing is performed via the the
*<https://www.smooks.org/xsd/smooks/jms-routing-2.0.xsd[jms:router]>*
configuration from the
https://www.smooks.org/xsd/smooks/jms-routing-2.0.xsd configuration
namespace.

The following is an example
<https://www.smooks.org/xsd/smooks/jms-routing-2.0.xsd[jms:router]>
configuration that routes an "orderItem_xml" bean to a JMS Queue named
"smooks.exampleQueue" (also read the "Routing to File" example):

[source,xml]
----
<?xml version="1.0"?>  
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"  
                      xmlns:core="https://www.smooks.org/xsd/smooks/smooks-core-1.6.xsd"  
                      xmlns:jms="https://www.smooks.org/xsd/smooks/jms-routing-2.0.xsd"  
                      xmlns:ftl="https://www.smooks.org/xsd/smooks/freemarker-2.0.xsd">  

(1)     <resource-config selector="order,order-item">  
            <resource>org.smooks.engine.resource.visitor.dom.DomModelCreator</resource>  
        </resource-config>  

(2)     <jms:router routeOnElement="order-item" beanId="orderItem_xml" destination="smooks.exampleQueue">  
            <jms:message>  
                <!-- Need to use special FreeMarker variable ".vars" -->  
                <jms:correlationIdPattern>${order.@id}-${.vars["order-item"].@id}</jms:correlationIdPattern>  
            </jms:message>  
            <jms:highWaterMark mark="3"/>  
        </jms:router>  

(3)     <ftl:freemarker applyOnElement="order-item">  
            <!--  
             Note in the template that we need to use the special FreeMarker variable ".vars"  
             because of the hyphenated variable names ("order-item"). See http://freemarker.org/docs/ref_specvar.html.  
            -->  
            <ftl:template>/orderitem-split.ftl</ftl:template>  
            <ftl:use>  
                <!-- Bind the templating result into the bean context, from where  
                     it can be accessed by the JMSRouter (configured above). -->  
                <ftl:bindTo id="orderItem_xml"/>  
            </ftl:use>  
        </ftl:freemarker>  

</smooks-resource-list>
----

In this case, we route the result of a FreeMarker templating operation
to the JMS Queue (i.e. as a String). We could also have routed a full
Object Model, in which case it would be routed as a Serialized
ObjectMessage.

===== Routing to a Database using SQL

Routing to a database is also quite easy. Please read the "Routing to
File" section above before reading this section.

So we take the same scenario as with the File Routing example above, but
this time we want to route the order and order item data to a database.
This is what we want to achieve:

image:../assets/images/Db-split-required.png[Image:db-split-required.png]

First we need to define a set of Java bindings that extract the order
and order-item data from the data stream:

[source,xml]
----
<?xml version="1.0"?>  
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"   
                      xmlns:jb="https://www.smooks.org/xsd/smooks/javabean-1.6.xsd">  

    <!-- Extract the order data... -->  
    <jb:bean beanId="order" class="java.util.Hashtable" createOnElement="order">  
        <jb:value property="orderId" decoder="Integer" data="order/@id"/>  
        <jb:value property="customerNumber" decoder="Long" data="header/customer/@number"/>  
        <jb:value property="customerName" data="header/customer"/>  
    </jb:bean>  

    <!-- Extract the order-item data... -->  
    <jb:bean beanId="orderItem" class="java.util.Hashtable" createOnElement="order-item">  
        <jb:value property="itemId" decoder="Integer" data="order-item/@id"/>  
        <jb:value property="productId" decoder="Long" data="order-item/product"/>  
        <jb:value property="quantity" decoder="Integer" data="order-item/quantity"/>  
        <jb:value property="price" decoder="Double" data="order-item/price"/>  
    </jb:bean>  

</smooks-resource-list>
----

Next we need to define datasource configuration and a number of
<db:executor> configurations that will use that datasource to insert the
data that was bound into the Java Object model into the database.

The Datasource configuration (namespace
https://www.smooks.org/xsd/smooks/datasource-1.5.xsd) for retrieving
direct database connection:

[source,xml]
----
<?xml version="1.0"?>  
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"
                      xmlns:ds="https://www.smooks.org/xsd/smooks/datasource-1.5.xsd">  

    <ds:direct bindOnElement="#document"  
              datasource="DBExtractTransformLoadDS"  
              driver="org.hsqldb.jdbcDriver"  
              url="jdbc:hsqldb:hsql://localhost:9201/smooks-hsql-9201"  
              username="sa"  
              password=""  
              autoCommit="false"/>  

</smooks-resource-list>
----

or it is possible to use a JNDI datasource for retrieving a database
connection:

[source,xml]
----
<?xml version="1.0"?>  
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"
                      xmlns:ds="https://www.smooks.org/xsd/smooks/datasource-1.5.xsd">  

    <!-- This JNDI datasource can handle JDBC and JTA transactions or   
         it can leave the transaction managment to an other external component.  
         An external component could be an other Smooks visitor, the EJB transaction manager  
         or you can do it your self. -->  
    <ds:JNDI  
         bindOnElement="#document"  
         datasource="DBExtractTransformLoadDS"  
         datasourceJndi="java:/someDS"  
         transactionManager="JTA"  
         transactionJndi="java:/mockTransaction"  
         targetProfile="jta"/>  

</smooks-resource-list>
----

The datasource schema describes and documents how you can configure the
datasource.

The <db:executor> configurations (namespace
https://www.smooks.org/xsd/smooks/db-routing-2.0.xsd):

[source,xml]
----
<?xml version="1.0"?>  
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"  
                      xmlns:db="https://www.smooks.org/xsd/smooks/db-routing-2.0.xsd">  

    <!-- Assert whether it's an insert or update. Need to do this just before we do the insert/update... -->  
    <db:executor executeOnElement="order-items" datasource="DBExtractTransformLoadDS" executeBefore="true">  
        <db:statement>select OrderId from ORDERS where OrderId = ${order.orderId}</db:statement>  
        <db:resultSet name="orderExistsRS"/>  
    </db:executor>  

    <!-- If it's an insert (orderExistsRS.isEmpty()), insert the order before we process the order items... -->  
    <db:executor executeOnElement="order-items" datasource="DBExtractTransformLoadDS" executeBefore="true">  
        <condition>orderExistsRS.isEmpty()</condition>  
        <db:statement>INSERT INTO ORDERS VALUES(${order.orderId}, ${order.customerNumber}, ${order.customerName})</db:statement>  
    </db:executor>  

    <!-- And insert each orderItem... -->  
    <db:executor executeOnElement="order-item" datasource="DBExtractTransformLoadDS" executeBefore="false">  
        <condition>orderExistsRS.isEmpty()</condition>  
        <db:statement>INSERT INTO ORDERITEMS VALUES (${orderItem.itemId}, ${order.orderId}, ${orderItem.productId}, ${orderItem.quantity}, ${orderItem.price})</db:statement>  
    </db:executor>  

    <!-- Ignoring updates for now!! -->  

</smooks-resource-list>
----

Check out the db-extract-transform-load example.

=== Message Splitting & Routing

Please refer to the link:#splitting--routing[Splitting & Routing]
section in the previous section.

== Extending Smooks

All existing Smooks functionality (Java Binding, EDI processing, etc...)
is built through extension of a number of well defined APIs. We will
look at these APIs in the coming sections.

The main extension points/APIs in Smooks are:

. *Reader APIs*: Those for processing Source/Input data (Readers) so as
to make it consumable by other Smooks components as a series of well
defined hierarchical events (based on the SAX event model) for all of
the message fragments and sub-fragments.
. *Visitor APIs*: Those for consuming the message fragment SAX events
produced by a source/input reader.

Another very important aspect of writing Smooks extensions is how these
components are configured. Because this is common to all Smooks
components, we will look at this first.

=== Configuring Smooks Components

All Smooks components are configured in exactly the same way. As far as
the Smooks Core code is concerned, all Smooks components are "resources"
and are configured via a ResourceConfig instance, which we talked about
in earlier sections.

Smooks provides mechanisms for constructing namespace (XSD) specific XML
configurations for components, but the most basic configuration (and the
one that maps directly to the ResourceConfig class) is the basic XML
configuration from the base configuration namespace
(https://www.smooks.org/xsd/smooks-2.0.xsd).

[source,xml]
----
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd">  

    <resource-config selector="">  
        <resource></resource>  
        <param name=""></param>  
    </resource-config>  

</smooks-resource-list>
----

Where:

* The *selector* attribute is the mechanism by which the resource is
"selected" e.g. can be an XPath for a visitor. We'll see more of this in
the coming sections.
* The *resource* element is the actual resource. This can be a Java
Class name or some other form of resource (such as a template). For the
purposes of this section however, lets just assume the resource to by a
Java Class name.
* The *param* elements are configuration parameters for the resource
defined in the resource element.

Smooks takes care of all the details of creating the runtime
representation of the resource (e.g. constructing the class named in the
the resource element) and injecting all the configuration parameters. It
also works out what the resource type is, and from that, how to
interpret things like the selector e.g., if the resource is a visitor
instance, it knows the selector is an XPath, selecting a Source message
fragment.

==== Configuration Annotations

After your component has been created, you need to configure it with the
element details. This is done using the _@Inject_ annotation.

===== @Inject

The _Inject_ annotation reflectively injects the named parameter (from
the elements) having the same name as the annotated property itself (the
name can actually be different, but by default, it matches against the
name of the component property).

Suppose we have a component as follows:

[source,java]
----
public class DataSeeder {  

    @Inject  
    private File seedDataFile;

    public File getSeedDataFile() {
        return seedDataFile;  
    }  

    // etc...  
}
----

We configure this component in Smooks as follows:

[source,xml]
----
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd">  

    <resource-config selector="dataSeeder">  
        <resource>com.acme.DataSeeder</resource>  
        <param name="seedDataFile">./seedData.xml</param>  
    </resource-config>  

</smooks-resource-list>
----

This annotation eliminates a lot of noisy code from your component
because it:

* Handles decoding of the value before setting it on the annotated
component property. Smooks provides type converters for all the main
types (Integer, Double, File, Enums, etc...), but you can implement and
use a custom TypeConverter where the out-of-the-box converters don't
cover specific decoding requirements. Smooks will automatically use your
custom converter if it is registered. See the TypeConverter Javadocs for
details on registering a TypeConverter implementation such that Smooks
will automatically locate it for converting a specific data type.
* Supports enum constraints for the injected property, generating a
configuration exception where the configured value is not one of the
defined choice values. For example, you may have a property which has a
constrained value set of "ON" and "OFF". You can use an enum for the
property type to constrain the value, raise exceptions, etc...:

[source,java]
----
@Inject
private OnOffEnum foo;
----

* Can specify default property values:

[source,java]
----
@Inject
private Boolean foo = true;
----

* Can specify whether the property is optional:

[source,java]
----
@Inject
private java.util.Optional<Boolean> foo;
----

By default, all properties are required but setting a default implicitly
marks the property as being optional.

===== @PostConstruct and @PreDestroy

The _@Inject_ annotation is great for configuring your component with
simple values, but sometimes your component needs more involved
configuration for which we need to write some "initialization" code. For
this, Smooks provides the _@PostConstruct_ annotation.

On the other side of this, there are times when we need to undo work
performed during initialization when the associated Smooks instance is
being discarded (garbage collected) e.g. to release some resources
acquired during initialization, etc... For this, Smooks provides the
_@PreDestroy_ annotation.

The basic initialization/un-initialization sequence can be described as
follows:

[source,java]
----
smooks = new Smooks(..);  

    // Initialize all annotated components  
    @PostConstruct  

        // Use the smooks instance through a series of filterSource invocations...  
        smooks.filterSource(...);  
        smooks.filterSource(...);  
        smooks.filterSource(...);  
        ... etc ...  

smooks.close();  

    // Uninitialize all annotated components  
    @PreDestroy
----

In the following example, lets assume we have a component that opens
multiple connections to a database on initialization and then needs to
release all those database resources when we close the Smooks instance.

[source,java]
----
public class MultiDataSourceAccessor {  

    @Inject  
    private File dataSourceConfig;

    Map<String, Datasource> datasources = new HashMap<String, Datasource>();  

    @PostConstruct  
    public void createDataSources() {  
        // Add DS creation code here....  
        // Read the dataSourceConfig property to read the DS configs...  
    }  

    @PreDestroy  
    public void releaseDataSources() {  
        // Add DS release code here....  
    }  

    // etc...  
}
----

*Notes*:

* The _@PostConstruct_ and _@PreDestroy_ methods must be public,
zero-arg methods.
* The _@Inject_ properties are all initialized before the first
_@PostConstruct_ method is called. Therefore, you can use the _@Inject_
component properties as input to the initialization process.
* The _@PreDestroy_ methods are all called in response to a call to the
_Smooks.close_ method.

==== Defining Custom Configuration Namespaces

Smooks supports a mechanism for defining custom configuration namespaces
for components. This allows you to support custom, XSD based
(validatable), configurations for your components Vs treating them all
as vanilla Smooks resources via the base configuration.

The basic process involves:

. Writing an configuration XSD for your component that extends the base
https://www.smooks.org/xsd/smooks-2.0.xsd configuration namespace. This
XSD must be supplied on the classpath with your component. It must be
located in the _/META-INF_ folder and have the same path as the
namespace URI. For example, if your extended namespace URI is
"http://www.acme.com/schemas/smooks/acme-core-1.0.xsd", then the
physical XSD file must be supplied on the classpath in
"/META-INF/schemas/smooks/acme-core-1.0.xsd".
. Writing a Smooks configuration namespace mapping configuration file
that maps the custom namespace configuration into a _ResourceConfig_
instance. This file must be named (by convention) based on the name of
the namespace it is mapping and must be physically located on the
classpath in the same folder as the XSD. Extending the above example,
the Smooks mapping file would be
"/META-INF/schemas/smooks/acme-core-1.0.xsd-smooks.xml". Note the
"-smooks.xml" postfix.

The easiest way to get familiar with this mechanism is by looking at
existing extended namespace configurations within the Smooks code
itself. All Smooks components (including e.g. the Java Binding
functionality) use this mechanism for defining their configurations.
Smooks Core itself defines a number of extended configuration namesaces,
https://github.com/smooks/smooks/smooks-core/src/main/resources/META-INF/xsd/smooks/[as
can be seen in the source].

=== Implementing a Source Reader

Implementing and configuring a new Source Reader for Smooks is
straightforward. The Smooks specific parts of the process are easy and
are not really the issue. The level of effort involved is a function of
the complexity of the Source data format for which you are implementing
the reader.

Implementing a Reader for your custom data format immediately opens all
Smooks capabilities to that data format e.g. Java Binding, Templating,
Persistence, Validation, Splitting & Routing, etc... So a relatively
small investment can yield a quite significant return. The only
requirement, from a Smooks perspective, is that the Reader implements
the standard
http://java.sun.com/j2se/1.5.0/docs/api/org/xml/sax/XMLReader.html[org.xml.sax.XMLReader]
interface from the Java JDK. However, if you want to be able to
configure the Reader implementation, it needs to implement the
link:/javadoc/v1.7.1/smooks/org/milyn/xml/SmooksXMLReader.html[org.smooks.api.resource.reader.SmooksXMLReader]
interface (which is just an extension of
http://java.sun.com/j2se/1.5.0/docs/api/org/xml/sax/XMLReader.html[org.xml.sax.XMLReader]).
So, you can easily use (or extend) an existing
http://java.sun.com/j2se/1.5.0/docs/api/org/xml/sax/XMLReader.html[org.xml.sax.XMLReader]
implementation, or implement a new Reader from scratch.

Let's now look at a simple example of implementing a Reader for use with
Smooks. In this example, we will implement a Reader that can read a
stream of Comma Separated Value (CSV) records, converting the CSV stream
into a stream of SAX events that can be processed by Smooks, allowing
you to do all the things Smooks allows (Java Binding, etc...).

We start by implementing the basic Reader class:

[source,java]
----
public class MyCSVReader implements SmooksXMLReader {  

    // Implement all of the XMLReader methods...  
}
----

Two methods from the
_http://java.sun.com/j2se/1.5.0/docs/api/org/xml/sax/XMLReader.html[XMLReader]_
interface are of particular interest:

* *setContentHandler(ContentHandler)*: This method is called by Smooks
Core. It sets the
_http://java.sun.com/j2se/1.5.0/docs/api/org/xml/sax/ContentHandler.html[ContentHandler]_
instance for the reader. The
_http://java.sun.com/j2se/1.5.0/docs/api/org/xml/sax/ContentHandler.html[ContentHandler]_
instance methods are called from inside the _parse(InputSource)_ method.
* *parse(InputSource)*: This is the method that receives the Source data
input stream, parses it (i.e. in the case of this example, the CSV
stream) and generates the SAX event stream through calls to the
_http://java.sun.com/j2se/1.5.0/docs/api/org/xml/sax/ContentHandler.html[ContentHandler]_
instance supplied in the _setContentHandler(ContentHandler)_ method.

We need to configure our CSV reader with the names of the fields
associated with the CSV records. Configuring a custom reader
implementation is the same as for any Smooks component, as described in
the link:#configuring-smooks-components[Configuring Smooks Components]
section above.

So focusing a little more closely on the above methods and our fields
configuration:

[source,java]
----
public class MyCSVReader implements SmooksXMLReader {

    private ContentHandler contentHandler;

    @Inject
    private String[] fields; // Auto decoded and injected from the "fields" <param> on the reader config.

    public void setContentHandler(ContentHandler contentHandler) {
        this.contentHandler = contentHandler;
    }

    public void parse(InputSource csvInputSource) throws IOException, SAXException {
        // TODO: Implement parsing of CSV Stream...
    }

    // Other XMLReader methods...
}
----

So now we have our basic Reader implementation stub. We can start
writing unit tests to test the new reader implementation.

First thing we need is some sample CSV input. Lets use a simple list of
names:

(_names.csv_)

....
Tom,Fennelly  
Mike,Fennelly  
Mark,Jones
....

Second thing we need is a test Smooks configuration to configure Smooks
with our MyCSVReader. As stated before, everything in Smooks is a
resource and can be configured with the basic configuration. While this
works fine, it's a little noisy, so Smooks provides a basic
configuration element specifically for the purpose of configuring a
reader. The configuration for our test looks like the following:

(_mycsvread-config.xml_)

[source,xml]
----
<?xml version="1.0"?>  
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd">  

    <reader class="com.acme.MyCSVReader">  
        <params>  
            <param name="fields">firstname,lastname</param>  
        </params>  
    </reader>  

</smooks-resource-list>
----

And of course we need the JUnit test class:

[source,java]
----
public class MyCSVReaderTest extends TestCase {

    public void test() {
        Smooks smooks = new Smooks(getClass().getResourceAsStream("mycsvread-config.xml"));
        StringResult serializedCSVEvents = new StringResult();

        smooks.filterSource(new StreamSource(getClass().getResourceAsStream("names.csv")), serializedCSVEvents);

        System.out.println(serializedCSVEvents);

        // TODO: add assertions, etc...
    }
}
----

So now we have a basic setup with our custom Reader implementation, as
well as a unit test that we can use to drive our development. Of course,
our reader _parse_ method is not doing anything yet and our test class
is not making any assertions, etc... So lets start implementing the
_parse_ method:

[source,java]
----
public class MyCSVReader implements SmooksXMLReader {

    private ContentHandler contentHandler;

    @Inject
    private String[] fields; // Auto decoded and injected from the "fields" <param> on the reader config.

    public void setContentHandler(ContentHandler contentHandler) {
        this.contentHandler = contentHandler;
    }

    public void parse(InputSource csvInputSource) throws IOException, SAXException {
        BufferedReader csvRecordReader = new BufferedReader(csvInputSource.getCharacterStream());
        String csvRecord;

        // Send the start of message events to the handler...
        contentHandler.startDocument();
        contentHandler.startElement(XMLConstants.NULL_NS_URI, "message-root", "", new AttributesImpl());

        csvRecord = csvRecordReader.readLine();
        while(csvRecord != null) {
            String[] fieldValues = csvRecord.split(",");

            // perform checks...

            // Send the events for this record...
            contentHandler.startElement(XMLConstants.NULL_NS_URI, "record", "", new AttributesImpl());
            for(int i = 0; i < fields.length; i++) {
                contentHandler.startElement(XMLConstants.NULL_NS_URI, fields[i], "", new AttributesImpl());
                contentHandler.characters(fieldValues[i].toCharArray(), 0, fieldValues[i].length());
                contentHandler.endElement(XMLConstants.NULL_NS_URI, fields[i], "");            
            }
            contentHandler.endElement(XMLConstants.NULL_NS_URI, "record", "");            

            csvRecord = csvRecordReader.readLine();    
        }

        // Send the end of message events to the handler...
        contentHandler.endElement(XMLConstants.NULL_NS_URI, "message-root", "");
        contentHandler.endDocument();
    }

    // Other XMLReader methods...
}
----

If you run the unit test class now, you should see the following output
on the console (formatted):

[source,xml]
----
<message-root>  
    <record>  
        <firstname>Tom</firstname>  
        <lastname>Fennelly</lastname>  
    </record>  
    <record>  
        <firstname>Mike</firstname>  
        <lastname>Fennelly</lastname>  
    </record>  
    <record>  
        <firstname>Mark</firstname>  
        <lastname>Jones</lastname>  
    </record>  
</message-root>
----

After this, it is just a case of expanding the tests, hardening the
reader implementation code, etc...

Now you can use your reader to perform all sorts of operations supported
by Smooks. As an example, the following configuration could be used to
bind the names into a List of PersonName objects:

_(java-binding-config.xml)_

[source,xml]
----
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd" xmlns:jb="https://www.smooks.org/xsd/smooks/javabean-1.6.xsd">  

    <reader class="com.acme.MyCSVReader">  
        <params>  
            <param name="fields">firstname,lastname</param>  
        </params>  
    </reader>  

    <jb:bean beanId="peopleNames" class="java.util.ArrayList" createOnElement="message-root">  
        <jb:wiring beanIdRef="personName" />  
    </jb:bean>  

    <jb:bean beanId="personName" class="com.acme.PersonName" createOnElement="message-root/record">  
        <jb:value property="first" data="record/firstname" />  
        <jb:value property="last" data="record/lastname" />  
    </jb:bean>  

</smooks-resource-list>
----

And then a test for this configuration could look as follows:

[source,java]
----
public class MyCSVReaderTest extends TestCase {  

    public void test_java_binding() {  
        Smooks smooks = new Smooks(getClass().getResourceAsStream("java-binding-config.xml"));  
        JavaResult javaResult = new JavaResult();  

        smooks.filterSource(new StreamSource(getClass().getResourceAsStream("names.csv")), javaResult);  

        List<PersonName> peopleNames = (List<PersonName>) javaResult.getBean("peopleNames");  

        // TODO: add assertions etc  
    }  
}
----

For more on Java Binding, see the link:#java-binding[Java Binding]
section.

*Tips*:

* Reader instances are never used concurrently. Smooks Core will create
a new instance for every message, or, will pool and reuse instances as
per the link:#filter-settings[_readerPoolSize_ FilterSettings property].
* If your Reader requires access to the Smooks ExecutionContext for the
current filtering context, your Reader needs to implement the
link:/javadoc/v1.7.1/smooks/org/milyn/xml/SmooksXMLReader.html%22[SmooksXMLReader]
interface.
* If your Source data is a binary data stream your Reader must implement
the
link:/javadoc/v1.7.1/smooks/org/milyn/delivery/StreamReader.html[StreamReader]
interface. See next section.
* You can programmatically configure your reader (e.g. in your unit
tests) using a _GenericReaderConfigurator_ instance, which you then set
on the _Smooks_ instance.
* While the basic configuration is fine, it's possible to define a
custom configuration namespace (XSD) for your custom CSV Reader
implementation. This topic is not covered here. Review the source code
to see the extended configuration namespace for the Reader
implementations suppled with Smooks (out-of-the-box) e.g. the EDIReader,
CSVReader, JSONReader, etc... From this, you should be able to work out
how to do this for your own custom Reader.

==== Implementing a Binary Source Reader

Prior to Smooks v1.5, binary readers needed to implement the
_StreamReader_ interface. This is no longer a requirement. All
_XMLReader_ instances receive an _InputSource_ (to their parse method)
that contains an _InputStream_ if the _InputStream_ was provided in the
_StreamSource_ passed in the _Smooks.filterSource_ method call. This
means that all _XMLReader_ instance are guaranteed to receive an
_InputStream_ if one is available, so no need to mark the _XMLReader_
instance.

==== Implementing a Flat File Source Reader

In Smooks v1.5 we tried to make it a little easier to implement a custom
reader for reading flat file data formats. By flat file we mean "record"
based data formats, where the data in the message is structured in flat
records as opposed to a more hierarchical structure. Examples of this
would be Comma Separated Value (CSV) and Fixed Length Field (FLF). The
new API introduced in Smooks v1.5 should remove the complexity of the
XMLReader API (as outlined above).

The API is composed of 2 interfaces plus a number of support classes.
These interfaces work as a pair. They need to be implemented if you wish
to use this API for processing a custom Flat File format not already
supported by Smooks.

[source,java]
----
/**
 * {@link RecordParser} factory class.
 * <p/>
 * Configurable by the Smooks {@link org.smooks.cdr.annotation.Configurator}
 */
public interface RecordParserFactory {

    /**
     * Create a new Flat File {@link RecordParser} instance.
     * @return A new {@link RecordParser} instance.
     */
    RecordParser newRecordParser();
}


/**
 * Flat file Record Parser.
 */
public interface RecordParser<T extends RecordParserFactory>  {

    /**
     * Set the parser factory that created the parser instance.
     * @param factory The parser factory that created the parser instance.
     */
    void setRecordParserFactory(T factory);

    /**
     * Set the Flat File data source on the parser.
     * @param source The flat file data source.
     */
    void setDataSource(InputSource source);

    /**
     * Parse the next record from the message stream and produce a {@link Record} instance.
     * @return The records instance.
     * @throws IOException Error reading message stream.
     */
    Record nextRecord() throws IOException;

}
----

Obviously the _RecordParserFactory_ implementation is responsible for
creating the _RecordParser_ instances for the Smooks runtime. The
_RecordParserFactory_ is the class that Smooks configures, so it is in
here you place all your _@Inject_ details. The created _RecordParser_
instances are supplied with a reference to the _RecordParserFactory_
instance that created them, so it is easy enough the provide them with
access to the configuration via getters on the _RecordParserFactory_
implementation.

The _RecordParser_ implementation is responsible for parsing out each
_Records_ (a _Record_ contains a set of _Fields_) in the _nextRecord()_
method. Each instance is supplied with the _Reader_ to the message
stream via the _setReader(Reader)_ method. The _RecordParser_ should
store a reference to this _Reader_ and use it in the _nextRecord()_
method. A new instance of a given _RecordParser_ implementation is
created for each message being filtered by Smooks.

Configuring your implementation in the Smooks configuration is as simple
as the following:

[source,xml]
----
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"
                      xmlns:ff="https://www.smooks.org/xsd/smooks/flatfile-1.6.xsd">  

    <ff:reader fields="first,second,third" parserFactory="com.acme.ARecordParserFactory">  
        <params>  
            <param name="aConfigParameter">aValue</param>  
            <param name="bConfigParameter">bValue</param>  
        </params>  
    </ff:reader>  

    <!--  
 Other Smooks configurations e.g. <jb:bean> configurations  
 -->  

</smooks-resource-list>
----

The Flat File configuration also supports basic Java binding
configurations, inlined in the reader configuration.

[source,xml]
----
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"
                      xmlns:ff="https://www.smooks.org/xsd/smooks/flatfile-1.6.xsd">  

    <ff:reader fields="firstname,lastname,gender,age,country" parserFactory="com.acme.PersonRecordParserFactory">  
        <!-- The field names must match the property names on the Person class. -->  
        <ff:listBinding beanId="people" class="com.acme.Person" />  
    </ff:reader>  

</smooks-resource-list>
----

To execute this configuration:

[source,java]
----
Smooks smooks = new Smooks(configStream);  
JavaResult result = new JavaResult();  

smooks.filterSource(new StreamSource(messageReader), result);  

List<Person> people = (List<Person>) result.getBean("people");
----

Smooks also supports creation of Maps from the record set:

[source,xml]
----
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"
                      xmlns:ff="https://www.smooks.org/xsd/smooks/flatfile-1.6.xsd">  

    <ff:reader fields="firstname,lastname,gender,age,country" parserFactory="com.acme.PersonRecordParserFactory">  
        <ff:mapBinding beanId="people" class="com.acme.Person" keyField="firstname" />  
    </ff:reader>  

</smooks-resource-list>
----

The above configuration would produce a Map of Person instances, keyed
by the "firstname" value of each Person. It would be executed as
follows:

[source,java]
----
Smooks smooks = new Smooks(configStream);  
JavaResult result = new JavaResult();  

smooks.filterSource(new StreamSource(messageReader), result);  

Map<String, Person> people = (Map<String, Person>) result.getBean("people");  

Person tom = people.get("Tom");  
Person mike = people.get("Mike");
----

link:#virtual-object-models-maps--lists[Virtual Models] are also
supported, so you can define the *class* attribute as a java.util.Map
and have the record field values bound into Map instances, which are in
turn added to a List or a Map.

===== VariableFieldRecordParser and VariableFieldRecordParserFactory

VariableFieldRecordParser and VariableFieldRecordParserFactory are
abstract implementations of the _RecordParser_ and _RecordParserFactory_
interface. They provide very useful base implementations for a Flat File
Reader, providing base support for:

* The utility java binding configurations as outlined in the previous
section.
* Support for "variable field" records i.e. a flat file message that
contains multiple record definitions. The different records are
identified by the value of the first field in the record and are defined
as follows: _fields="book[name,author] | magazine[*]"_. Note the record
definitions are pipe separated. "book" records will have a first field
value of "book" while "magazine" records will have a first field value
of "magazine". Astrix ("*") as the field definition for a record
basically tells the reader to generate the field names in the generated
events (e.g. "field_0", "field_1", etc...).
* The ability to read the next record chunk, with support for a simple
record delimiter, or a regular expression (regex) pattern that marks the
beginning of each record.

The CSV and Regex readers are implemented using these abstract classes.
See the
https://github.com/smooks/smooks/tree/v1.5.1/smooks-examples/csv-variable-record/[csv-variable-record]
and
https://github.com/smooks/smooks/tree/v1.5.1/smooks-examples/flatfile-to-xml-regex/[flatfile-to-xml-regex]
examples. The
https://github.com/smooks/smooks/tree/v1.5.1/smooks-cartridges/flatfile/src/main/java/org/milyn/flatfile/regex[Regex
Reader] implementation is also a good example that can be used as a
basis for your own custom flat file reader.

=== Implementing a Fragment Visitor

Visitors are the workhorse of Smooks. Most of the out-of-the-box
functionality in Smooks (Java binding, templating, persistence, etc...)
was created by creating one or more visitors. Visitors often collaborate
through the _ExecutionContext_ and _ApplicationContext_ context objects,
accomplishing a common goal by working together.

Smooks supports three types of visitor implementations:

. *SAX NG* based implementations based on the
link:/javadoc/v2.0.0/smooks/org/smooks/delivery/sax/ng/SaxNgVisitor.html[SaxNgVisitor]
sub-interfaces.
. *SAX* based implementations based on the
link:/javadoc/v2.0.0/smooks/org/smooks/delivery/sax/SAXVisitor.html[SAXVisitor]
sub-interfaces.
. *DOM* based implementations based on the
link:/javadoc/v2.0.0/smooks/org/smooks/delivery/dom/DOMVisitor.html[DOMVisitor]
sub-interfaces.

Your implementation can support both SAX and DOM, but in general, we
recommend people to stick with implementing a SAX NG-only visitor. As
yet, we have not found a use case that could not be solved through the
SAX NG-based implementations, while at the same time, the SAX NG-based
implementations are usually easier to create, and offer clear advantages
in terms of performance. For this reason, we will concentrate on the SAX
NG API only here.

*Note*: Smooks treats all visitors as stateless objects. A visitor
instance must be usable concurrently across multiple messages, that is,
across multiple concurrent calls to the _Smooks.filterSource_ method.
All state associated with the current _Smooks.filterSource_ execution
must be stored in the _ExecutionContext_. For more details see the
link:#executioncontext-and-applicationcontext[ExecutionContext and
ApplicationContex] section.

==== SAX NG Visitor API

The SAX NG visitor API is made up of a number of interfaces. These
interfaces are based on the
http://java.sun.com/j2se/1.5.0/docs/api/org/xml/sax/ContentHandler.html[SAX
events] that a SaxNgVisitor implementation can capture and processes.
Depending on the use case being solved with the SaxNgVisitor
implementation, you may need to implement one or all of these
interfaces.

*link:/javadoc/v2.0.0/smooks/org/smooks/delivery/sax/ng/BeforeVisitor.html[BeforeVisitor]*:
Captures the _startElement_ SAX event for the targeted fragment element:

[source,java]
----
public interface BeforeVisitor extends Visitor {  

    void visitBefore(Element element, ExecutionContext executionContext);  
}
----

*link:/javadoc/v2.0.0/smooks/org/smooks/delivery/sax/ng/ChildrenVisitor.html[ChildrenVisitor]*:
Captures the _character_ based SAX events for the targeted fragment
element, as well as Smooks generated (pseudo) events corresponding to
the _startElement_ events of child fragment elements:

[source,java]
----
public interface ChildrenVisitor extends Visitor {  

    void visitChildText(CharacterData characterData, ExecutionContext executionContext) throws SmooksException, IOException;  

    void visitChildElement(Element childElement, ExecutionContext executionContext) throws SmooksException, IOException;  
}
----

*link:/javadoc/v2.0.0/smooks/org/smooks/delivery/sax/ng/AfterVisitor.html[AfterVisitor]*:
Captures the _endElement_ SAX event for the targeted fragment element:

[source,java]
----
public interface AfterVisitor extends Visitor {  

    void visitAfter(Element element, ExecutionContext executionContext);  
}
----

As a convenience for those implementations that need to capture all the
SAX events, the above three interfaces are pulled together into a single
interface in the
link:/javadoc/v2.0.0/smooks/org/smooks/delivery/sax/ng/ElementVisitor.html[ElementVisitor]
interface.

Illustrating these events using a piece of XML:

[source,xml]
----
<message>  
    <target-fragment>      <--- BeforeVisitor.visitBefore  
        Text!!                       <--- ChildrenVisitor.visitChildText   
        <child>                      <--- ChildrenVisitor.visitChildElement  
        </child>                   
    </target-fragment>     <--- AfterVisitor.visitAfter  
</message>
----

*Note*: _Of course, the above is just an illustration of a Source
message event stream and it looks like XML, but could be EDI, CSV, JSON,
etc... Think of this as just an XML serialization of a Source message
event stream, serialized as XML for easy reading._

*https://docs.oracle.com/javase/8/docs/api/org/w3c/dom/Element.html[Element]*:
As can be seen from the above SAX NG interfaces, the
https://docs.oracle.com/javase/8/docs/api/org/w3c/dom/Element.html[Element]
type is passed in all method calls. This object contains details about
the targeted fragment element, including attributes and their values.
We'll discuss text accumulation and _StreamResult_ writing in the coming
sections.

==== Text Accumulation

SAX is a stream based processing model. It doesn't create a Document
Object Model (DOM) of any form. It doesn't "accumulate" event data in
any way. This is why it is a suitable processing model for processing
huge message streams.

The
https://docs.oracle.com/javase/8/docs/api/org/w3c/dom/Element.html[Element]
will always contain attributes associated with the targeted element, but
will not contain the fragment child text data, whose SAX events
(_ChildrenVisitor.visitChildText_) occur between the
_BeforeVisitor.visitBefore_ and _AfterVisitor.visitAfter_ events (see
above illustration). The filter does not accumulate text events on the
_Element_ because, as already stated, that could result in a significant
performance drain. Of course the downside to this is the fact that if
your _SaxNgVisitor_ implementation needs access to the text content of a
fragment, you need to explicitly tell Smooks to *accumulate text* for
the targeted fragment. This is done by stashing the text into a memento
from within the _ChildrenVisitor.visitChildText_ method and then
restoring the memento from within the _AfterVisitor.visitAfter_ method
implementation of your _SaxNgVisitor_ as shown below:

[source,java]
----
public class MyVisitor implements ChildrenVisitor, AfterVisitor {

    @Override
    public void visitChildText(CharacterData characterData, ExecutionContext executionContext) {
        executionContext.getMementoCaretaker().stash(new TextAccumulatorMemento(new NodeVisitable(characterData.getParentNode()), this), textAccumulatorMemento -> textAccumulatorMemento.accumulateText(characterData.getTextContent()));
    }

    @Override
    public void visitChildElement(Element childElement, ExecutionContext executionContext) {

    }

    @Override
    public void visitAfter(Element element, ExecutionContext executionContext) {
        TextAccumulatorMemento textAccumulatorMemento = new TextAccumulatorMemento(new NodeVisitable(element), this);
        executionContext.getMementoCaretaker().restore(textAccumulatorMemento);
        String fragmentText = textAccumulatorMemento.getTextContent();

        // ... etc ...
    }
}
----

It is a bit ugly having to implement _ChildrenVisitor.visitChildText_
just to tell Smooks to accumulate the text events for the targeted
fragment. For that reason, we have the _@TextConsumer_ annotation that
can be used to annotate your _SaxNgVisitor_ implementation, removing the
need to implement the _ChildrenVisitor.visitChildText_ method:

[source,java]
----
@TextConsumer
public class MyVisitor implements AfterVisitor {

    public void visitAfter(Element element, ExecutionContext executionContext) {
        String fragmentText = element.getTextContent();

        // ... etc ...
    }
}
----

Note that all of the fragment text will not be available until the
_AfterVisitor.visitAfter_ event.

==== StreamResult Writing/Serialization

The _Smooks.filterSource(Source, Result)_ method can take one or more of
a number of different _Result_ type implementations, one of which is the
_http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/stream/StreamResult.html[StreamResult]_
class (see link:#multiple-outputsresults[Multiple Outputs/Results]). By
default, Smooks will always serialize the full Source event stream as
XML to any
_http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/stream/StreamResult.html[StreamResult]_
instance provided to the _Smooks.filterSource(Source, Result)_ method.

So, if the Source provided to the _Smooks.filterSource(Source, Result)_
method is an XML stream and a
_http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/stream/StreamResult.html[StreamResult]_
instance is provided as one of the _Result_ instances, the Source XML
will be written out to the
_http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/stream/StreamResult.html[StreamResult]_
unmodified, unless the Smooks instance is configured with one or more
_SaxNgVisitor_ implementations that modify one or more fragments. In
other words, Smooks streams the Source in and back out again through the
_http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/stream/StreamResult.html[StreamResult]_
instance. This *default serialization* behavior can be turned on/off by
link:#filter-settings[configuring the filter settings].

If you want to modify the serialized form of one of the message
fragments (i.e. "transform"), you need to implement a _SaxNgVisitor_ to
do so and target it at the message fragment using an XPath-like
expression.

*Note*: _Of course, you can also modify the serialized form of a message
fragment using one of the out-of-the-box link:#templating[Templating]
components. These components are also_ SaxNgVisitor _implementations._

The key to implementing a _SaxNgVisitor_ geared towards transforming the
serialized form of a fragment is telling Smooks that the _SaxNgVisitor_
implementation in question will be writing to the _StreamResult_. You
need to tell Smooks this because Smooks supports targeting of multiple
_SaxNgVisitor_ implementations at a single fragment, but only one
_SaxNgVisitor_ is allowed to write to the _StreamResult_, per fragment.
If a second _SaxNgVisitor_ attempts to write to the _StreamResult_, a
_SAXWriterAccessException_ will result and you will need to modify your
Smooks configuration.

In order to be "the one" that writes to the _StreamResult_, the
_SaxNgVisitor_ needs to *acquire ownership* of the _Writer_ to the
_StreamResult_. It does this by simply making a call to the
_ExecutionContext.getWriter().write(...)_ method from inside the
_BeforeVisitor.visitBefore_ methods implementation:

[source,java]
----
public class MyVisitor implements ElementVisitor {

    @Override
    public void visitBefore(Element element, ExecutionContext executionContext) {
        Writer writer = executionContext.getWriter();

        // ... write the start of the fragment...
    }

    @Override
    public void visitChildText(CharacterData characterData, ExecutionContext executionContext) {        
        Writer writer = executionContext.getWriter();

        // ... write the child text...
    }

    @Override
    public void visitChildElement(Element childElement, ExecutionContext executionContext) {
    }

    @Override
    public void visitAfter(Element element, ExecutionContext executionContext) {
        Writer writer = executionContext.getWriter();

        // ... close the fragment...
    }
}
----

*Note*: If you need to control serialization of sub-fragments you need
to reset the _Writer_ instance so as to divert serialization of the
sub-fragments. You do this by calling _ExecutionContext.setWriter_.

Sometimes you know that the target fragment you are
serializing/transforming will never have sub-fragments. In this
situation, it's a bit ugly to have to implement the
_BeforeVisitor.visitBefore_ method just to make a call to the
_ExecutionContext.getWriter().write(...)_ method to acquire ownership of
the _Writer_. For this reason, we have the _@StreamResultWriter_
annotation. Used in combination with the _@TextConsumer_ annotation, we
can remove the need to implement all but the _AfterVisitor.visitAfter_
method:

[source,java]
----
@TextConsumer
@StreamResultWriter
public class MyVisitor implements AfterVisitor {

    public void visitAfter(Element element, ExecutionContext executionContext) {
        Writer writer = executionContext.getWriter();

        // ... serialize to the writer ...
    }
}
----

===== DomToXmlWriter

Smooks provides the _DomToXmlWriter_ class to make serializing of
_Element_ data, as XML, a little easier. This class allows you to write
a _SaxNgVisitor_ implementation like:

[source,java]
----
@StreamResultWriter
public class MyVisitor implements ElementVisitor {

    private DomToXmlWriter xmlWriter = new DomToXmlWriter(true, true);

    @Override
    public void visitBefore(Element element, ExecutionContext executionContext) {
        try {
            xmlWriter.writeStartElement(element, executionContext.getWriter());
        } catch (IOException e) {
            throw new SmooksException(e);
        }
    }

    @Override
    public void visitChildText(CharacterData characterData, ExecutionContext executionContext) {
        try {
            xmlWriter.writeText(characterData, executionContext.getWriter());
        } catch (IOException e) {
            throw new SmooksException(e);
        }
    }

    @Override
    public void visitChildElement(Element element, ExecutionContext executionContext) throws SmooksException, IOException {
    }

    @Override
    public void visitAfter(Element element, ExecutionContext executionContext) throws SmooksException, IOException {
        try {
            xmlWriter.writeEndElement(element, executionContext.getWriter());
        } catch (IOException e) {
            throw new SmooksException(e);
        }
    }
}
----

You may have noticed that the arguments in the _DomToXmlWriter_
constructor are boolean. This is the _closeEmptyElements_ and
_rewriteEntities_ args which should be based on the _closeEmptyElements_
and _rewriteEntities_ link:#filter-settings[filter setting],
respectively. Smooks provides a small code optimization/assist here. If
you annotate the _DomToXmlWriter_ field with _@Inject_, Smooks will
create the _DomToXmlWriter_ instance and initialize it with the
_closeEmptyElements_ and _rewriteEntities_ link:#filter-settings[filter
setting] for the associated Smooks instance:

[source,java]
----
@TextConsumer
public class MyVisitor implements AfterVisitor {

    @Inject
    private DomToXmlWriter xmlWriter;

    public void visitAfter(Element element, ExecutionContext executionContext) throws SmooksException, IOException {
        try {
            xmlWriter.writeStartElement(element, executionContext.getWriter());
            xmlWriter.writeText(element, executionContext.getWriter());
            xmlWriter.writeEndElement(element, executionContext.getWriter());
        } catch (IOException e) {
            throw new SmooksException(e);
        }
    }
}
----

==== Visitor Configuration

_SaxNgVisitor_ configuration works in exactly the same way as any other
Smooks component. See link:#configuring-smooks-components[Configuring
Smooks Components].

The most important thing to note with respect to configuring visitor
instances is the fact that the _selector_ attribute is interpreted as an
XPath (like) expression. For more on this see the docs on
link:#selectors[Selectors].

Also note that visitors can be programmatically configured on a Smooks
instance. Among other things, this is very useful for unit testing.

===== Example Visitor Configuration

Let's assume we have a very simple _SaxNgVisitor_ implementation as
follows:

[source,java]
----
@TextConsumer
public class ChangeItemState implements AfterVisitor {

    @Inject
    private DomToXmlWriter xmlWriter;

    @Inject
    private String newState;

    public void visitAfter(Element element, ExecutionContext executionContext) {
        element.setAttribute("state", newState);

        try {
            xmlWriter.writeStartElement(element, executionContext.getWriter());
            xmlWriter.writeText(element, executionContext.getWriter());
            xmlWriter.writeEndElement(element, executionContext.getWriter());
        } catch (IOException e) {
            throw new SmooksException(e);
        }
    }
}
----

Declaratively configuring _ChangeItemState_ to fire on fragments having
a status of "OK" is as simple as:

[source,xml]
----
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd">  

    <resource-config selector="order-items/order-item[@status = 'OK']">  
        <resource>com.acme.ChangeItemState </resource>  
        <param name="newState">COMPLETED</param>  
    </resource-config>  

</smooks-resource-list>
----

Of course it would be really nice to be able to define a cleaner and
more strongly typed configuration for the _ChangeItemState_ component,
such that it could be configured something like:

[source,xml]
----
<smooks-resource-list xmlns="https://www.smooks.org/xsd/smooks-2.0.xsd"
                      xmlns:order="http://www.acme.com/schemas/smooks/order.xsd">  

    <order:changeItemState itemElement="order-items/order-item[@status = 'OK']" newState="COMPLETED" />  

</smooks-resource-list>
----

For details on this, see the section on
link:#defining-custom-configuration-namespaces[Defining Custom
Configuration Namespaces].

This visitor could also be programmatically configured on a Smooks as
follows:

[source,java]
----
Smooks smooks = new Smooks();  

smooks.addVisitor(new ChangeItemState().setNewState("COMPLETED"), "order-items/order-item[@status = 'OK']");  

smooks.filterSource(new StreamSource(inReader), new StreamResult(outWriter));
----

==== Visitor Instance Lifecycle

One aspect of the visitor lifecycle has already been discussed in the
general context of Smooks component
link:#initialize-and-uninitialize[initialization and uninitialization].

Smooks supports two additional component lifecycle events, specific to
visitor components, via the _ExecutionLifecycleCleanable_ and
_VisitLifecycleCleanable_ interfaces.

===== ExecutionLifecycleCleanable

Visitor components implementing this lifecycle interface will be able to
perform post _Smooks.filterSource_ lifecycle operations.

[source,java]
----
public interface ExecutionLifecycleCleanable extends Visitor {  

    void executeExecutionLifecycleCleanup(ExecutionContext executionContext);  
}
----

The basic call sequence can be described as follows (note the
executeExecutionLifecycleCleanup calls):

[source,java]
----
smooks = new Smooks(..);  

        smooks.filterSource(...);  
            ** VisitorXX.executeExecutionLifecycleCleanup **  
        smooks.filterSource(...);  
            ** VisitorXX.executeExecutionLifecycleCleanup **  
        smooks.filterSource(...);  
            ** VisitorXX.executeExecutionLifecycleCleanup **  
        ... etc ...
----

This lifecycle method allows you to ensure that resources scoped around
the _Smooks.filterSource_ execution lifecycle can be cleaned up for the
associated _ExecutionContext_.

===== VisitLifecycleCleanable

Visitor components implementing this lifecycle interface will be able to
perform post _AfterVisitor.visitAfter_ lifecycle operations.

[source,java]
----
public interface VisitLifecycleCleanable extends Visitor {  

    void executeVisitLifecycleCleanup(ExecutionContext executionContext);  
}
----

The basic call sequence can be described as follows (note the
executeVisitLifecycleCleanup calls):

....
smooks.filterSource(...);

    <message>
        <target-fragment>      <--- VisitorXX.visitBefore
            Text!!                       <--- VisitorXX.visitChildText  
            <child>                      <--- VisitorXX.visitChildElement
            </child>                 
        </target-fragment>     <--- VisitorXX.visitAfter
        ** VisitorXX.executeVisitLifecycleCleanup **
        <target-fragment>      <--- VisitorXX.visitBefore
            Text!!                       <--- VisitorXX.visitChildText  
            <child>                      <--- VisitorXX.visitChildElement
            </child>                 
        </target-fragment>     <--- VisitorXX.visitAfter
        ** VisitorXX.executeVisitLifecycleCleanup **
    </message>
    VisitorXX.executeExecutionLifecycleCleanup

smooks.filterSource(...);

    <message>
        <target-fragment>      <--- VisitorXX.visitBefore
            Text!!                       <--- VisitorXX.visitChildText  
            <child>                      <--- VisitorXX.visitChildElement
            </child>                 
        </target-fragment>     <--- VisitorXX.visitAfter
        ** VisitorXX.executeVisitLifecycleCleanup **
        <target-fragment>      <--- VisitorXX.visitBefore
            Text!!                       <--- VisitorXX.visitChildText  
            <child>                      <--- VisitorXX.visitChildElement
            </child>                 
        </target-fragment>     <--- VisitorXX.visitAfter
        ** VisitorXX.executeVisitLifecycleCleanup **
    </message>
    VisitorXX.executeExecutionLifecycleCleanup
....

This lifecycle method allows you to ensure that resources scoped around
a single fragment execution of a SaxNgVisitor implementation can be
cleaned up for the associated _ExecutionContext_.

==== ExecutionContext and ApplicationContext

Smooks provides these two Context objects for storing of state
information.

The _ExecutionContext_ is scoped specifically around a single execution
of a _Smooks.filterSource_ method. All Smooks visitors must be stateless
within the context of a single _Smooks.filterSource_ execution, allowing
the visitor to be used across multiple concurrent executions of the
_Smooks.filterSource_ method. All data stored in an _ExecutionContext_
instance will be lost on completion of the _Smooks.filterSource_
execution. The _ExecutionContext_ is supplied in all visitor API message
event calls._

The _ApplicationContext_ is scoped around the associated _Smooks_
instance i.e. only one _ApplicationContext_ instance exists per Smooks
instance. This context object can be used to store data that needs to be
maintained (and accessible) across multiple _Smooks.filterSource_
executions. Components (any component, including _SaxNgVisitor_
components) can gain access to their associated _ApplicationContext_
instance by declaring an _ApplicationContext_ class property and
annotating it with _@Inject:

[source,java]
----
public class MySmooksComponent {  

    @Inject  
    private ApplicationContext appContext;  

    // etc...  
}
----

== Apache Camel Integration

The Camel-Smooks integration lets you to access all the features of
Smooks from within Camel. You can take an existing Smooks configuration
and use this in your Camel routes using one of the options that are
described in this chapter. If you are interested in routing from Smooks
to Camel endpoints the please refer to the Camel section in
link:#camel[Routing] chapter.

Using Smooks in Camel can be done in three ways:

. link:#smookscomponent[SmooksComponent]
. link:#smooksdataformat[SmooksDataformat]
. link:#smooksprocessor[SmooksProcessor]

=== SmooksComponent

The SmooksComponent is a Camel
https://camel.apache.org/component.html[Component] which can used when
you want to process the Camel Message Body using Smooks. You can do this
by adding a route in your Camel route configuration:

[source,java]
----
from("file://inputDir?noop=true")  
.to("smooks://smooks-config.xml")  
.to("jms:queue:order")
----

The Smooks Component is configured with a mandatory configuration file,
which is 'smooks-config-xml' in the example above. By just looking at
the above route definition it is not clear what type of output that the
SmooksComponent is producing. This is actually expressed in the Smooks
configuration using the link:#exporting-results[exports] element.

If you prefer/require programmatic configuration of Smooks you can use
the link:#smooksprocessor[SmooksProcessor] to achieve this.

==== Options

An Apache Component can take options that are specified after the Smooks
configuration file. Currently only one option is available for the
SmooksComponent:

. *reportPath* which is path (including the file name) to the Smooks
Excecution Report to be generated.

=== SmooksDataformat

SmooksDataFormat is a Camel DataFormat which is capable of transforming
from one dataformat to another and back again. You would use this when
you are only interested in transforming from one format to another and
not interested in other Smooks features.

Below is an example of using SmooksDataFormat to transform a comma
separated value string into a java.util.List of Customer object
instances:

[source,java]
----
SmooksDataFormat sdf = new SmooksDataFormat("csv-smooks-unmarshal-config.xml");
from("direct:unmarshal")
.unmarshal(sdf)
.convertBodyTo(List.class)
.to("mock:result");
----

=== SmooksProcessor

Using the _SmooksProcessor_ gives you full control over Smooks, for
example if you want to programatically create the underlying Smooks
instance you’d use the SmooksProcessor. When using the SmooksProcessor
you can pass a Smooks instance to its constructor and prior to that
programmatically configure Smooks.

Below is an example of using the SmooksProcessor in a Camel route:

[source,java]
----
Smooks smooks = new Smooks("edi-to-xml-smooks-config.xml");
ExecutionContext context = smooks.createExecutionContext();
...  
SmooksProcessor processor = new SmooksProcessor(smooks, context);

from("file://input?noop=true")
.process(processor)
.to("mock:result");
----

Similar to the SmooksComponent we have not specified the result type
that Smooks produces (if any that is). Instead this is expressed in the
Smooks configuration using the link:#exporting-results[exports] element
or you can do the same programmatically like this:

[source,java]
----
Smooks smooks = new Smooks();
ExecutionContext context = smooks.createExecutionContext();
smooks.setExports(new Exports(StringResult.class));
SmooksProcessor processor = new SmooksProcessor(smooks, context);
...
from("file://input?noop=true")
.process(processor)
.to("mock:result");
----

=== Apache Camel Examples

Please see the
https://github.com/smooks/smooks/tree/v1.7.1/smooks-examples/camel[Apache
Camel examples] in the examples page.